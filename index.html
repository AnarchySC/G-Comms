<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>G-COMMS | GBRS Communications System v.0.9.2</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üì°</text></svg>">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      background: linear-gradient(135deg, #0a0f0a 0%, #1a1f1a 50%, #0f1a0f 100%);
      min-height: 100vh;
      color: #e0ffe0;
    }
    ::placeholder { color: #4a6a4a; }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none; width: 14px; height: 14px; border-radius: 50%;
      background: #e0ffe0; cursor: pointer; box-shadow: 0 0 10px rgba(0,255,100,0.5);
    }
    input[type="range"]::-moz-range-thumb {
      width: 14px; height: 14px; border-radius: 50%; background: #e0ffe0;
      cursor: pointer; border: none; box-shadow: 0 0 10px rgba(0,255,100,0.5);
    }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } }
    @keyframes glow { 0%, 100% { box-shadow: 0 0 20px rgba(0,255,100,0.2); } 50% { box-shadow: 0 0 30px rgba(0,255,100,0.4); } }
    @keyframes flashAlert { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes soundWave { 0%, 100% { height: 4px; } 50% { height: 16px; } }
    .user-chip { cursor: grab; user-select: none; transition: all 0.2s; }
    .user-chip:active { cursor: grabbing; }
    .user-chip.dragging { opacity: 0.5; transform: scale(0.95); }
    .channel-drop-zone { transition: all 0.2s; }
    .channel-drop-zone.drag-over { background: rgba(0,255,100,0.1); border-color: rgba(0,255,100,0.5) !important; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    const VoIPApp = () => {
      const [sessionState, setSessionState] = useState('lobby');
      const [sessionCode, setSessionCode] = useState('');
      const [joinCode, setJoinCode] = useState('');
      const [username, setUsername] = useState('');
      const [error, setError] = useState('');
      const [connectedUsers, setConnectedUsers] = useState([]);
      const [myStatus, setMyStatus] = useState('standby');
      const [myChannelId, setMyChannelId] = useState(null);
      
      const [teams, setTeams] = useState([
        { id: 1, name: 'Alpha Squad', volume: 80, color: '#00ff66' },
        { id: 2, name: 'Bravo Unit', volume: 80, color: '#ffcc00' },
      ]);
      const [newTeamName, setNewTeamName] = useState('');
      const [newTeamColor, setNewTeamColor] = useState('#00ff66');
      const [showCreateModal, setShowCreateModal] = useState(false);
      
      // Host controls
      const [hostListenChannels, setHostListenChannels] = useState(new Set());
      const [hostSpeakChannel, setHostSpeakChannel] = useState(null); // null = none, 'all' = all channels, or channel id
      const [allCallActive, setAllCallActive] = useState(false);
      
      const [audioLevel, setAudioLevel] = useState(0);
      const [globalMute, setGlobalMute] = useState(false);
      const [whistleActive, setWhistleActive] = useState(false);
      const [incomingWhistle, setIncomingWhistle] = useState(null);
      const [draggedUser, setDraggedUser] = useState(null);
      
      const peerRef = useRef(null);
      const connectionsRef = useRef(new Map());
      const localStreamRef = useRef(null);
      const audioContextRef = useRef(null);
      const analyserRef = useRef(null);
      const animationRef = useRef(null);
      const isHostRef = useRef(false);
      const audioElementsRef = useRef(new Map());
      const gainNodesRef = useRef(new Map());
      const teamsRef = useRef(teams);
      const myStatusRef = useRef(myStatus);
      const myChannelIdRef = useRef(myChannelId);
      const connectedUsersRef = useRef(connectedUsers);
      const hostListenChannelsRef = useRef(hostListenChannels);
      const hostSpeakChannelRef = useRef(hostSpeakChannel);
      const allCallActiveRef = useRef(allCallActive);

      useEffect(() => { teamsRef.current = teams; }, [teams]);
      useEffect(() => { myStatusRef.current = myStatus; }, [myStatus]);
      useEffect(() => { myChannelIdRef.current = myChannelId; }, [myChannelId]);
      useEffect(() => { connectedUsersRef.current = connectedUsers; }, [connectedUsers]);
      useEffect(() => { hostListenChannelsRef.current = hostListenChannels; }, [hostListenChannels]);
      useEffect(() => { hostSpeakChannelRef.current = hostSpeakChannel; }, [hostSpeakChannel]);
      useEffect(() => { allCallActiveRef.current = allCallActive; }, [allCallActive]);

      const isSpeaking = isHostRef.current 
        ? (hostSpeakChannel !== null && !globalMute)
        : (myChannelId !== null && !globalMute);

      const colorOptions = [
        '#00ff66', '#ffcc00', '#ff6b6b', '#4ecdc4', '#a855f7', 
        '#3b82f6', '#f97316', '#ec4899', '#84cc16', '#06b6d4'
      ];

      const statusConfig = {
        standby: { color: '#666666', label: 'STANDBY', icon: '‚ö´' },
        ready: { color: '#00ff66', label: 'READY', icon: 'üü¢' },
        dead: { color: '#ff4444', label: 'DOWN', icon: 'üî¥' },
        wait: { color: '#ffaa00', label: 'WAIT ONE', icon: 'üü°' }
      };

      // Update audio routing based on channel assignments
      const updateAudioRouting = useCallback(() => {
        if (!audioContextRef.current) return;
        
        connectedUsersRef.current.forEach(user => {
          if (user.peerId === peerRef.current?.id) return;
          
          const gainNode = gainNodesRef.current.get(user.peerId);
          if (!gainNode) return;
          
          let shouldHear = false;
          
          if (isHostRef.current) {
            // Host hears users from channels they're listening to
            shouldHear = hostListenChannelsRef.current.has(user.channelId);
          } else {
            // Regular users only hear people in their channel
            shouldHear = user.channelId === myChannelIdRef.current && user.channelId !== null;
          }
          
          // Also check if user is speaking (host with all-call or matching channel)
          if (user.speaking) {
            if (user.isHost) {
              // Host speaking - check if all-call or specific channel
              if (user.speakingToAll || user.speakingChannel === myChannelIdRef.current || isHostRef.current) {
                shouldHear = true;
              }
            }
          }
          
          gainNode.gain.value = (shouldHear && !globalMute) ? 1 : 0;
        });
      }, [globalMute]);

      useEffect(() => {
        updateAudioRouting();
      }, [connectedUsers, myChannelId, hostListenChannels, globalMute, updateAudioRouting]);

      const broadcastStatus = useCallback((newStatus) => {
        setMyStatus(newStatus);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'status-update', peerId: peerRef.current?.id, status: newStatus });
          }
        });
      }, []);

      const broadcastSpeakingState = useCallback((isSpeakingNow, speakingChannel = null, speakingToAll = false) => {
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ 
              type: 'speaking-update', 
              peerId: peerRef.current?.id, 
              speaking: isSpeakingNow,
              speakingChannel: speakingChannel,
              speakingToAll: speakingToAll
            });
          }
        });
      }, []);

      useEffect(() => {
        if (sessionState !== 'lobby') {
          if (isHostRef.current) {
            broadcastSpeakingState(isSpeaking, hostSpeakChannel, allCallActive);
          } else {
            broadcastSpeakingState(isSpeaking, myChannelId, false);
          }
        }
      }, [isSpeaking, sessionState, hostSpeakChannel, myChannelId, allCallActive, broadcastSpeakingState]);

      // Move user to channel (host only)
      const moveUserToChannel = useCallback((userId, channelId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, channelId } : u
        ));
        
        // Broadcast to all
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'user-moved', peerId: userId, channelId });
          }
        });
        
        // If moving ourselves
        if (userId === peerRef.current?.id) {
          setMyChannelId(channelId);
        }
      }, []);

      const playWhistle = useCallback((type = 'attention') => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        if (type === 'attention') {
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(800, ctx.currentTime);
          oscillator.frequency.linearRampToValueAtTime(1600, ctx.currentTime + 0.3);
          oscillator.frequency.linearRampToValueAtTime(1200, ctx.currentTime + 0.6);
          gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
          gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.7);
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.7);
        } else if (type === 'alert') {
          oscillator.type = 'square';
          oscillator.frequency.setValueAtTime(1000, ctx.currentTime);
          gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
          gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.1);
          gainNode.gain.setValueAtTime(0.2, ctx.currentTime + 0.15);
          gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.25);
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.3);
        } else if (type === 'urgent') {
          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(1200, ctx.currentTime);
          gainNode.gain.setValueAtTime(0.15, ctx.currentTime);
          for (let i = 0; i < 3; i++) {
            const t = ctx.currentTime + i * 0.15;
            gainNode.gain.setValueAtTime(0.15, t);
            gainNode.gain.setValueAtTime(0, t + 0.1);
          }
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.5);
        }
      }, []);

      const broadcastWhistle = useCallback((type) => {
        playWhistle(type);
        setWhistleActive(true);
        setTimeout(() => setWhistleActive(false), 800);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) connData.conn.send({ type: 'whistle', whistleType: type, from: username });
        });
      }, [playWhistle, username]);

      // Hotkeys
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (sessionState === 'lobby') return;
          if (e.target.tagName === 'INPUT') return;
          
          if (e.ctrlKey && e.shiftKey && (e.key === 'A' || e.key === 'a')) {
            e.preventDefault(); broadcastStatus('ready'); return;
          }
          if (e.ctrlKey && e.altKey && (e.key === 'd' || e.key === 'D')) {
            e.preventDefault(); broadcastStatus('dead'); return;
          }
          if (e.ctrlKey && e.altKey && (e.key === 'w' || e.key === 'W')) {
            e.preventDefault(); broadcastStatus('wait'); return;
          }
          if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'm') {
            e.preventDefault(); setGlobalMute(prev => !prev); return;
          }
          if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'w') {
            e.preventDefault(); broadcastWhistle('attention'); return;
          }
          // Host: Ctrl+number to toggle listening to channel
          if (isHostRef.current && e.ctrlKey && !e.shiftKey && !e.altKey && e.key >= '1' && e.key <= '9') {
            e.preventDefault();
            const channelIndex = parseInt(e.key) - 1;
            if (channelIndex < teamsRef.current.length) {
              const channelId = teamsRef.current[channelIndex].id;
              setHostListenChannels(prev => {
                const next = new Set(prev);
                if (next.has(channelId)) next.delete(channelId);
                else next.add(channelId);
                return next;
              });
            }
            return;
          }
          // Host: Ctrl+Shift+number to speak to channel
          if (isHostRef.current && e.ctrlKey && e.shiftKey && e.key >= '1' && e.key <= '9') {
            e.preventDefault();
            const channelIndex = parseInt(e.key) - 1;
            if (channelIndex < teamsRef.current.length) {
              const channelId = teamsRef.current[channelIndex].id;
              setHostSpeakChannel(prev => prev === channelId ? null : channelId);
              setAllCallActive(false);
            }
            return;
          }
          // Host: Ctrl+0 for all-call
          if (isHostRef.current && e.ctrlKey && e.key === '0') {
            e.preventDefault();
            setAllCallActive(prev => !prev);
            if (!allCallActiveRef.current) {
              setHostSpeakChannel('all');
            } else {
              setHostSpeakChannel(null);
            }
            return;
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [sessionState, broadcastWhistle, broadcastStatus]);

      const generateCode = () => {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
        return code;
      };

      const initPeer = useCallback((peerId) => {
        return new Promise((resolve, reject) => {
          const peer = new Peer(peerId, { debug: 1 });
          peer.on('open', (id) => { console.log('Connected:', id); resolve(peer); });
          peer.on('error', (err) => {
            if (err.type === 'unavailable-id') reject(new Error('Session code already in use'));
            else if (err.type === 'peer-unavailable') reject(new Error('Session not found'));
            else reject(err);
          });
          peerRef.current = peer;
        });
      }, []);

      const getLocalStream = useCallback(async () => {
        if (!localStreamRef.current) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
              audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } 
            });
            localStreamRef.current = stream;
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
            analyserRef.current = audioContextRef.current.createAnalyser();
            const source = audioContextRef.current.createMediaStreamSource(stream);
            source.connect(analyserRef.current);
            analyserRef.current.fftSize = 256;
            return stream;
          } catch (err) {
            setError('Microphone access required');
            return null;
          }
        }
        return localStreamRef.current;
      }, []);

      useEffect(() => {
        if (isSpeaking && analyserRef.current) {
          const updateLevel = () => {
            const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
            analyserRef.current.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
            setAudioLevel(avg / 255);
            animationRef.current = requestAnimationFrame(updateLevel);
          };
          updateLevel();
        } else {
          if (animationRef.current) cancelAnimationFrame(animationRef.current);
          setAudioLevel(0);
        }
        return () => { if (animationRef.current) cancelAnimationFrame(animationRef.current); };
      }, [isSpeaking]);

      useEffect(() => {
        if (localStreamRef.current) {
          localStreamRef.current.getAudioTracks().forEach(track => { track.enabled = isSpeaking; });
        }
      }, [isSpeaking]);

      const handleData = useCallback((data, fromPeerId) => {
        console.log('Received:', data.type, 'from:', fromPeerId);
        
        if (data.type === 'whistle') {
          playWhistle(data.whistleType);
          setIncomingWhistle({ type: data.whistleType, from: data.from });
          setTimeout(() => setIncomingWhistle(null), 2000);
        } else if (data.type === 'status-update') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, status: data.status } : u));
        } else if (data.type === 'speaking-update') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { 
            ...u, 
            speaking: data.speaking,
            speakingChannel: data.speakingChannel,
            speakingToAll: data.speakingToAll
          } : u));
        } else if (data.type === 'user-moved') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, channelId: data.channelId } : u));
          if (data.peerId === peerRef.current?.id) {
            setMyChannelId(data.channelId);
          }
        } else if (data.type === 'user-joined') {
          setConnectedUsers(prev => {
            if (!prev.find(u => u.peerId === data.peerId)) {
              return [...prev, { 
                peerId: data.peerId, 
                username: data.username, 
                status: data.status || 'standby', 
                speaking: false,
                channelId: data.channelId || null,
                isHost: data.isHost || false
              }];
            }
            return prev;
          });
          
          if (isHostRef.current) {
            const conn = connectionsRef.current.get(fromPeerId)?.conn;
            if (conn?.open) {
              // Assign new user to first channel by default
              const defaultChannel = teamsRef.current.length > 0 ? teamsRef.current[0].id : null;
              conn.send({
                type: 'sync-state',
                teams: teamsRef.current,
                users: [...connectedUsersRef.current, { 
                  peerId: data.peerId, 
                  username: data.username, 
                  status: data.status || 'standby',
                  channelId: defaultChannel,
                  isHost: false
                }].map(u => u.peerId === data.peerId ? { ...u, channelId: defaultChannel } : u),
                yourChannelId: defaultChannel
              });
            }
            // Broadcast new user to others
            connectionsRef.current.forEach((connData, peerId) => {
              if (peerId !== fromPeerId && connData.conn?.open) {
                connData.conn.send({ 
                  type: 'user-joined', 
                  peerId: data.peerId, 
                  username: data.username, 
                  status: data.status || 'standby',
                  channelId: teamsRef.current.length > 0 ? teamsRef.current[0].id : null,
                  isHost: false
                });
              }
            });
          }
        } else if (data.type === 'sync-state') {
          setTeams(data.teams);
          setConnectedUsers(data.users);
          setMyChannelId(data.yourChannelId);
        } else if (data.type === 'teams-update') {
          setTeams(data.teams);
        } else if (data.type === 'user-left') {
          setConnectedUsers(prev => prev.filter(u => u.peerId !== data.peerId));
        }
      }, [playWhistle]);

      const setupConnection = useCallback((conn) => {
        conn.on('open', async () => {
          console.log('Connection opened:', conn.peer);
          connectionsRef.current.set(conn.peer, { ...connectionsRef.current.get(conn.peer), conn });
          conn.send({ 
            type: 'user-joined', 
            peerId: peerRef.current.id, 
            username: username, 
            status: myStatusRef.current,
            channelId: myChannelIdRef.current,
            isHost: isHostRef.current
          });
          const stream = await getLocalStream();
          if (stream && peerRef.current) {
            const call = peerRef.current.call(conn.peer, stream);
            setupCall(call);
          }
        });
        conn.on('data', (data) => handleData(data, conn.peer));
        conn.on('close', () => {
          console.log('Connection closed:', conn.peer);
          const audioEl = audioElementsRef.current.get(conn.peer);
          if (audioEl) { audioEl.srcObject = null; audioElementsRef.current.delete(conn.peer); }
          gainNodesRef.current.delete(conn.peer);
          connectionsRef.current.delete(conn.peer);
          setConnectedUsers(prev => prev.filter(u => u.peerId !== conn.peer));
        });
      }, [username, getLocalStream, handleData]);

      const setupCall = useCallback((call) => {
        call.on('stream', (remoteStream) => {
          console.log('Got stream from:', call.peer);
          
          // Create audio routing with gain node for channel-based control
          if (!audioContextRef.current) {
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
          }
          
          const source = audioContextRef.current.createMediaStreamSource(remoteStream);
          const gainNode = audioContextRef.current.createGain();
          gainNode.gain.value = 0; // Start muted, updateAudioRouting will enable
          source.connect(gainNode);
          gainNode.connect(audioContextRef.current.destination);
          
          gainNodesRef.current.set(call.peer, gainNode);
          
          // Also keep audio element for reference
          let audio = audioElementsRef.current.get(call.peer);
          if (!audio) {
            audio = new Audio();
            audio.autoplay = false; // We're using Web Audio API instead
            audioElementsRef.current.set(call.peer, audio);
          }
          audio.srcObject = remoteStream;
          
          connectionsRef.current.set(call.peer, { ...connectionsRef.current.get(call.peer), stream: remoteStream });
          
          // Trigger routing update
          setTimeout(() => updateAudioRouting(), 100);
        });
      }, [updateAudioRouting]);

      const hostSession = async () => {
        if (!username.trim()) { setError('Please enter your callsign'); return; }
        setError('');
        const code = generateCode();
        try {
          const peer = await initPeer(`gcomms-${code}-host`);
          peer.on('connection', (conn) => { console.log('Incoming:', conn.peer); setupConnection(conn); });
          peer.on('call', async (call) => {
            const stream = await getLocalStream();
            if (stream) { call.answer(stream); setupCall(call); }
          });
          isHostRef.current = true;
          setSessionCode(code);
          setSessionState('hosting');
          // Host listens to all channels by default
          setHostListenChannels(new Set(teams.map(t => t.id)));
          setConnectedUsers([{ 
            peerId: peer.id, 
            username: username, 
            isHost: true, 
            status: 'standby', 
            speaking: false,
            channelId: null // Host isn't in a specific channel
          }]);
        } catch (err) { setError(err.message); }
      };

      const joinSession = async () => {
        if (!username.trim()) { setError('Please enter your callsign'); return; }
        if (!joinCode.trim()) { setError('Please enter a session code'); return; }
        setError('');
        const code = joinCode.toUpperCase().replace(/[^A-Z0-9]/g, '');
        const uniqueId = `gcomms-${code}-${Date.now()}`;
        try {
          const peer = await initPeer(uniqueId);
          peer.on('connection', (conn) => setupConnection(conn));
          peer.on('call', async (call) => {
            const stream = await getLocalStream();
            if (stream) { call.answer(stream); setupCall(call); }
          });
          const hostPeerId = `gcomms-${code}-host`;
          const conn = peer.connect(hostPeerId, { reliable: true });
          conn.on('error', () => setError('Failed to connect'));
          setupConnection(conn);
          isHostRef.current = false;
          setSessionCode(code);
          setSessionState('joined');
          setConnectedUsers([{ peerId: peer.id, username: username, status: 'standby', speaking: false, channelId: null }]);
        } catch (err) { setError(err.message); }
      };

      const leaveSession = () => {
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'user-left', peerId: peerRef.current?.id });
            connData.conn.close();
          }
        });
        connectionsRef.current.clear();
        audioElementsRef.current.forEach(audio => { audio.srcObject = null; });
        audioElementsRef.current.clear();
        gainNodesRef.current.clear();
        if (localStreamRef.current) { localStreamRef.current.getTracks().forEach(track => track.stop()); localStreamRef.current = null; }
        if (peerRef.current) { peerRef.current.destroy(); peerRef.current = null; }
        setSessionState('lobby');
        setSessionCode('');
        setConnectedUsers([]);
        setMyChannelId(null);
        setMyStatus('standby');
        setHostListenChannels(new Set());
        setHostSpeakChannel(null);
        setAllCallActive(false);
        isHostRef.current = false;
      };

      const updateVolume = (id, volume) => {
        setTeams(prev => prev.map(t => t.id === id ? { ...t, volume } : t));
      };

      const updateColor = (id, color) => {
        const newTeams = teams.map(t => t.id === id ? { ...t, color } : t);
        setTeams(newTeams);
        syncTeams(newTeams);
      };

      const syncTeams = (newTeams) => {
        if (isHostRef.current) {
          connectionsRef.current.forEach((connData) => {
            if (connData.conn?.open) connData.conn.send({ type: 'teams-update', teams: newTeams });
          });
        }
      };

      const createTeam = () => {
        if (newTeamName.trim()) {
          const newTeam = { id: Date.now(), name: newTeamName.trim(), volume: 80, color: newTeamColor };
          const newTeams = [...teams, newTeam];
          setTeams(newTeams);
          setHostListenChannels(prev => new Set([...prev, newTeam.id]));
          setNewTeamName('');
          setNewTeamColor('#00ff66');
          setShowCreateModal(false);
          syncTeams(newTeams);
        }
      };

      const deleteTeam = (id) => {
        // Move users from this channel to unassigned
        setConnectedUsers(prev => prev.map(u => u.channelId === id ? { ...u, channelId: null } : u));
        const newTeams = teams.filter(t => t.id !== id);
        setTeams(newTeams);
        setHostListenChannels(prev => { const next = new Set(prev); next.delete(id); return next; });
        syncTeams(newTeams);
      };

      const copyCode = () => navigator.clipboard.writeText(sessionCode);

      useEffect(() => {
        setConnectedUsers(prev => prev.map(u => u.peerId === peerRef.current?.id ? { ...u, status: myStatus, speaking: isSpeaking } : u));
      }, [myStatus, isSpeaking]);

      // Drag and drop handlers
      const handleDragStart = (e, user) => {
        if (!isHostRef.current) return;
        setDraggedUser(user);
        e.dataTransfer.effectAllowed = 'move';
      };

      const handleDragOver = (e) => {
        if (!isHostRef.current || !draggedUser) return;
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      };

      const handleDragEnter = (e) => {
        if (!isHostRef.current || !draggedUser) return;
        e.currentTarget.classList.add('drag-over');
      };

      const handleDragLeave = (e) => {
        e.currentTarget.classList.remove('drag-over');
      };

      const handleDrop = (e, channelId) => {
        e.preventDefault();
        e.currentTarget.classList.remove('drag-over');
        if (!isHostRef.current || !draggedUser) return;
        if (!draggedUser.isHost) {
          moveUserToChannel(draggedUser.peerId, channelId);
        }
        setDraggedUser(null);
      };

      const getUsersInChannel = (channelId) => connectedUsers.filter(u => u.channelId === channelId && !u.isHost);
      const getUnassignedUsers = () => connectedUsers.filter(u => u.channelId === null && !u.isHost);

      return (
        <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #0a0f0a 0%, #1a1f1a 50%, #0f1a0f 100%)', fontFamily: '"JetBrains Mono", monospace', color: '#e0ffe0', padding: '40px 20px', position: 'relative', overflow: 'hidden' }}>
          <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 4px)', pointerEvents: 'none', zIndex: 1000 }} />
          <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, backgroundImage: 'linear-gradient(rgba(0,255,100,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,100,0.03) 1px, transparent 1px)', backgroundSize: '50px 50px', pointerEvents: 'none' }} />

          {incomingWhistle && (
            <div style={{ position: 'fixed', top: '20px', left: '50%', transform: 'translateX(-50%)', background: 'rgba(255,200,0,0.2)', border: '2px solid rgba(255,200,0,0.6)', borderRadius: '10px', padding: '15px 30px', zIndex: 2000, animation: 'flashAlert 0.3s ease-in-out infinite' }}>
              <span style={{ fontSize: '13px', letterSpacing: '2px', color: '#ffcc00' }}>‚ö†Ô∏è {incomingWhistle.from.toUpperCase()} ‚Äî {incomingWhistle.type.toUpperCase()} SIGNAL</span>
            </div>
          )}

          <div style={{ maxWidth: '1000px', margin: '0 auto', position: 'relative', zIndex: 1 }}>
            {/* Header */}
            <div style={{ textAlign: 'center', marginBottom: '35px' }}>
              <div style={{ display: 'inline-flex', alignItems: 'center', gap: '15px', marginBottom: '8px' }}>
                <div style={{ width: '12px', height: '12px', borderRadius: '50%', background: sessionState !== 'lobby' ? '#00ff66' : '#ff6600', boxShadow: sessionState !== 'lobby' ? '0 0 20px #00ff66' : '0 0 10px #ff6600', animation: sessionState !== 'lobby' ? 'pulse 2s infinite' : 'none' }} />
                <h1 style={{ fontSize: '38px', fontWeight: '300', letterSpacing: '6px', margin: 0, textShadow: '0 0 30px rgba(0,255,100,0.3)' }}>G-COMMS</h1>
                <div style={{ width: '12px', height: '12px', borderRadius: '50%', background: sessionState !== 'lobby' ? '#00ff66' : '#ff6600', boxShadow: sessionState !== 'lobby' ? '0 0 20px #00ff66' : '0 0 10px #ff6600', animation: sessionState !== 'lobby' ? 'pulse 2s infinite' : 'none' }} />
              </div>
              <p style={{ fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', margin: 0 }}>GBRS COMMUNICATIONS SYSTEM v.0.9.2</p>
            </div>

            {/* Lobby */}
            {sessionState === 'lobby' && (
              <div style={{ maxWidth: '450px', margin: '0 auto' }}>
                <div style={{ marginBottom: '30px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', marginBottom: '10px' }}>YOUR CALLSIGN</label>
                  <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} placeholder="Enter callsign..." style={{ width: '100%', padding: '15px 20px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '16px', outline: 'none', fontFamily: 'inherit' }} />
                </div>
                {error && <div style={{ padding: '12px', background: 'rgba(255,50,50,0.1)', border: '1px solid rgba(255,50,50,0.3)', borderRadius: '6px', color: '#ff6666', fontSize: '12px', marginBottom: '20px', textAlign: 'center' }}>{error}</div>}
                <button onClick={hostSession} style={{ width: '100%', padding: '20px', marginBottom: '15px', background: 'linear-gradient(135deg, rgba(0,255,100,0.15), rgba(0,200,80,0.1))', border: '2px solid rgba(0,255,100,0.4)', borderRadius: '12px', color: '#00ff66', fontSize: '14px', fontWeight: '600', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>üõ∞Ô∏è HOST NEW SESSION</button>
                <div style={{ textAlign: 'center', padding: '15px 0', color: '#4a6a4a', fontSize: '11px', letterSpacing: '2px' }}>‚Äî OR ‚Äî</div>
                <div style={{ background: 'rgba(0,20,0,0.4)', border: '1px solid rgba(0,255,100,0.15)', borderRadius: '12px', padding: '20px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', marginBottom: '10px' }}>SESSION CODE</label>
                  <input type="text" value={joinCode} onChange={(e) => setJoinCode(e.target.value.toUpperCase())} placeholder="XXXXXX" maxLength={6} style={{ width: '100%', padding: '15px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '24px', letterSpacing: '8px', outline: 'none', fontFamily: 'inherit', textAlign: 'center', marginBottom: '15px' }} />
                  <button onClick={joinSession} style={{ width: '100%', padding: '15px', background: 'transparent', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#8ac88a', fontSize: '12px', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>JOIN SESSION</button>
                </div>
              </div>
            )}

            {/* Session */}
            {(sessionState === 'hosting' || sessionState === 'joined') && (
              <>
                {/* Top Bar */}
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '12px 18px', background: 'rgba(0,20,0,0.6)', border: '1px solid rgba(0,255,100,0.2)', borderRadius: '10px', marginBottom: '15px', flexWrap: 'wrap', gap: '15px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '20px', flexWrap: 'wrap' }}>
                    <div>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>SESSION</span>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '4px' }}>
                        <span style={{ fontSize: '18px', letterSpacing: '4px', color: '#00ff66', fontWeight: '600' }}>{sessionCode}</span>
                        <button onClick={copyCode} style={{ background: 'rgba(0,255,100,0.1)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '4px', color: '#00ff66', padding: '4px 8px', fontSize: '9px', cursor: 'pointer', fontFamily: 'inherit' }}>COPY</button>
                      </div>
                    </div>
                    <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />
                    <div>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>ROLE</span>
                      <div style={{ fontSize: '12px', marginTop: '4px', color: isHostRef.current ? '#ffcc00' : '#00ff66' }}>
                        {isHostRef.current ? '‚òÖ COMMANDER' : '‚óè OPERATOR'}
                      </div>
                    </div>
                    {!isHostRef.current && myChannelId && (
                      <>
                        <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />
                        <div>
                          <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>MY CHANNEL</span>
                          <div style={{ fontSize: '12px', marginTop: '4px', color: teams.find(t => t.id === myChannelId)?.color || '#00ff66' }}>
                            {teams.find(t => t.id === myChannelId)?.name.toUpperCase() || 'UNASSIGNED'}
                          </div>
                        </div>
                      </>
                    )}
                    <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />
                    <div>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>STATUS</span>
                      <div style={{ fontSize: '12px', marginTop: '4px', color: statusConfig[myStatus].color }}>{statusConfig[myStatus].icon} {statusConfig[myStatus].label}</div>
                    </div>
                  </div>
                  <div style={{ display: 'flex', gap: '8px' }}>
                    <button onClick={() => setGlobalMute(!globalMute)} style={{ background: globalMute ? 'rgba(255,50,50,0.2)' : 'rgba(0,255,100,0.1)', border: `1px solid ${globalMute ? 'rgba(255,50,50,0.5)' : 'rgba(0,255,100,0.3)'}`, borderRadius: '6px', color: globalMute ? '#ff6666' : '#00ff66', padding: '8px 12px', fontSize: '14px', cursor: 'pointer' }}>{globalMute ? 'üîá' : 'üîä'}</button>
                    <button onClick={leaveSession} style={{ background: 'rgba(255,50,50,0.1)', border: '1px solid rgba(255,50,50,0.3)', borderRadius: '6px', color: '#ff6666', padding: '8px 14px', fontSize: '10px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>LEAVE</button>
                  </div>
                </div>

                {/* Host All-Call Panel */}
                {isHostRef.current && (
                  <div style={{ background: allCallActive ? 'rgba(255,50,50,0.15)' : 'rgba(0,20,0,0.5)', border: `2px solid ${allCallActive ? 'rgba(255,100,100,0.5)' : 'rgba(0,255,100,0.2)'}`, borderRadius: '10px', padding: '15px', marginBottom: '15px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '15px' }}>
                      <div>
                        <span style={{ fontSize: '11px', letterSpacing: '2px', color: '#ffcc00' }}>‚òÖ COMMANDER CONTROLS</span>
                        <div style={{ fontSize: '9px', color: '#5a7a5a', marginTop: '4px' }}>Ctrl+0: All-Call | Ctrl+1-9: Listen | Ctrl+Shift+1-9: Speak</div>
                      </div>
                      <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
                        <button 
                          onClick={() => { setAllCallActive(!allCallActive); setHostSpeakChannel(allCallActive ? null : 'all'); }}
                          style={{ 
                            padding: '12px 20px', 
                            background: allCallActive ? 'rgba(255,50,50,0.3)' : 'rgba(255,50,50,0.1)', 
                            border: `2px solid ${allCallActive ? '#ff6666' : 'rgba(255,100,100,0.4)'}`,
                            borderRadius: '8px', 
                            color: allCallActive ? '#ff6666' : '#ff9999', 
                            fontSize: '12px', 
                            fontWeight: '600',
                            letterSpacing: '2px', 
                            cursor: 'pointer', 
                            fontFamily: 'inherit',
                            animation: allCallActive ? 'pulse 0.5s infinite' : 'none'
                          }}
                        >
                          üì¢ ALL-CALL {allCallActive ? 'ACTIVE' : 'OFF'}
                        </button>
                      </div>
                    </div>
                  </div>
                )}

                {/* Signals Panel */}
                <div style={{ display: 'flex', gap: '10px', marginBottom: '15px', padding: '15px', background: 'rgba(0,20,0,0.4)', border: '1px solid rgba(255,200,0,0.2)', borderRadius: '10px', flexWrap: 'wrap' }}>
                  <span style={{ fontSize: '10px', letterSpacing: '2px', color: '#aa9944', display: 'flex', alignItems: 'center', marginRight: '10px' }}>SIGNALS</span>
                  <button onClick={() => broadcastWhistle('attention')} style={{ flex: 1, minWidth: '100px', padding: '10px 15px', background: 'rgba(255,200,0,0.1)', border: '1px solid rgba(255,200,0,0.4)', borderRadius: '6px', color: '#ffcc00', fontSize: '11px', cursor: 'pointer', fontFamily: 'inherit' }}>üìØ ATTENTION</button>
                  <button onClick={() => broadcastWhistle('alert')} style={{ flex: 1, minWidth: '100px', padding: '10px 15px', background: 'rgba(255,150,0,0.1)', border: '1px solid rgba(255,150,0,0.4)', borderRadius: '6px', color: '#ff9900', fontSize: '11px', cursor: 'pointer', fontFamily: 'inherit' }}>üîî ALERT</button>
                  <button onClick={() => broadcastWhistle('urgent')} style={{ flex: 1, minWidth: '100px', padding: '10px 15px', background: 'rgba(255,80,80,0.1)', border: '1px solid rgba(255,80,80,0.4)', borderRadius: '6px', color: '#ff6666', fontSize: '11px', cursor: 'pointer', fontFamily: 'inherit' }}>‚ö†Ô∏è URGENT</button>
                </div>

                {/* TX Meter */}
                {isSpeaking && (
                  <div style={{ marginBottom: '15px', padding: '12px 18px', background: 'rgba(0,20,0,0.6)', border: '1px solid rgba(0,255,100,0.2)', borderRadius: '8px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                      <span style={{ fontSize: '10px', letterSpacing: '2px', color: '#00ff66' }}>TX {isHostRef.current && allCallActive ? '(ALL)' : ''}</span>
                      <div style={{ flex: 1, height: '8px', background: 'rgba(0,0,0,0.5)', borderRadius: '4px', overflow: 'hidden' }}>
                        <div style={{ width: `${audioLevel * 100}%`, height: '100%', background: audioLevel > 0.7 ? 'linear-gradient(90deg, #00ff66, #ffff00, #ff3300)' : '#00ff66', transition: 'width 0.05s' }} />
                      </div>
                      <span style={{ fontSize: '11px', fontWeight: 'bold', color: audioLevel > 0.7 ? '#ff3300' : '#00ff66', minWidth: '35px' }}>{Math.round(audioLevel * 100)}%</span>
                    </div>
                  </div>
                )}

                {/* Hotkeys */}
                <div style={{ marginBottom: '15px', padding: '10px 15px', background: 'rgba(0,0,0,0.3)', borderRadius: '6px', display: 'flex', gap: '15px', flexWrap: 'wrap', justifyContent: 'center' }}>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+M</kbd> Mute</span>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Shift+A</kbd> Ready</span>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Alt+D</kbd> Down</span>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Alt+W</kbd> Wait</span>
                </div>

                {/* Unassigned Users (Host only) */}
                {isHostRef.current && getUnassignedUsers().length > 0 && (
                  <div style={{ background: 'rgba(100,50,0,0.2)', border: '1px solid rgba(255,150,0,0.3)', borderRadius: '10px', padding: '15px', marginBottom: '15px' }}>
                    <div style={{ fontSize: '10px', letterSpacing: '2px', color: '#ff9900', marginBottom: '10px' }}>‚ö†Ô∏è UNASSIGNED ‚Äî Drag to channel</div>
                    <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                      {getUnassignedUsers().map(user => (
                        <div
                          key={user.peerId}
                          draggable
                          onDragStart={(e) => handleDragStart(e, user)}
                          onDragEnd={() => setDraggedUser(null)}
                          className="user-chip"
                          style={{ display: 'flex', alignItems: 'center', gap: '8px', padding: '8px 12px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(255,150,0,0.4)', borderRadius: '6px' }}
                        >
                          <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: statusConfig[user.status || 'standby'].color }} />
                          <span style={{ fontSize: '11px' }}>{user.username.toUpperCase()}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Create Channel (Host) */}
                {isHostRef.current && (
                  <button onClick={() => setShowCreateModal(true)} style={{ width: '100%', padding: '16px', marginBottom: '15px', background: 'transparent', border: '2px dashed rgba(0,255,100,0.3)', borderRadius: '12px', color: '#4a8a4a', fontSize: '12px', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>+ CREATE CHANNEL</button>
                )}

                {/* Channels */}
                <div style={{ display: 'grid', gap: '15px' }}>
                  {teams.map((team, index) => {
                    const channelUsers = getUsersInChannel(team.id);
                    const isMyChannel = myChannelId === team.id;
                    const isHostListening = hostListenChannels.has(team.id);
                    const isHostSpeaking = hostSpeakChannel === team.id || hostSpeakChannel === 'all';
                    
                    return (
                      <div
                        key={team.id}
                        className="channel-drop-zone"
                        onDragOver={handleDragOver}
                        onDragEnter={handleDragEnter}
                        onDragLeave={handleDragLeave}
                        onDrop={(e) => handleDrop(e, team.id)}
                        style={{ 
                          background: 'linear-gradient(135deg, rgba(10,30,10,0.9), rgba(20,40,20,0.9))', 
                          border: `2px solid ${isMyChannel ? team.color : isHostListening ? `${team.color}66` : 'rgba(0,255,100,0.15)'}`,
                          borderRadius: '12px', 
                          padding: '18px',
                          boxShadow: isMyChannel || (isHostRef.current && isHostSpeaking) ? `0 0 30px ${team.color}33` : 'none'
                        }}
                      >
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
                          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                            <div style={{ position: 'relative' }}>
                              <div 
                                style={{ width: '16px', height: '16px', borderRadius: '50%', background: team.color, boxShadow: `0 0 10px ${team.color}66`, cursor: isHostRef.current ? 'pointer' : 'default' }}
                                onClick={(e) => { if (isHostRef.current) { const cp = e.currentTarget.nextElementSibling; cp.style.display = cp.style.display === 'none' ? 'flex' : 'none'; }}}
                              />
                              {isHostRef.current && (
                                <div style={{ display: 'none', position: 'absolute', top: '25px', left: '0', background: 'rgba(20,30,20,0.95)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', padding: '8px', gap: '6px', flexWrap: 'wrap', width: '140px', zIndex: 100 }}>
                                  {colorOptions.map(color => (<div key={color} onClick={() => updateColor(team.id, color)} style={{ width: '20px', height: '20px', borderRadius: '4px', background: color, cursor: 'pointer', border: team.color === color ? '2px solid white' : '2px solid transparent' }} />))}
                                </div>
                              )}
                            </div>
                            <div>
                              <h2 style={{ margin: 0, fontSize: '15px', fontWeight: '500', letterSpacing: '2px', color: team.color }}>{team.name.toUpperCase()}</h2>
                              <span style={{ fontSize: '9px', color: '#5a7a5a' }}>CH {index + 1} ‚Ä¢ {channelUsers.length} OPERATORS</span>
                            </div>
                          </div>
                          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                            {isMyChannel && !isHostRef.current && (
                              <span style={{ fontSize: '9px', padding: '4px 8px', background: `${team.color}33`, border: `1px solid ${team.color}`, borderRadius: '4px', color: team.color }}>YOUR CHANNEL</span>
                            )}
                            {isHostRef.current && (
                              <>
                                <button
                                  onClick={() => setHostListenChannels(prev => { const n = new Set(prev); if (n.has(team.id)) n.delete(team.id); else n.add(team.id); return n; })}
                                  style={{ padding: '6px 10px', background: isHostListening ? `${team.color}33` : 'rgba(0,0,0,0.3)', border: `1px solid ${isHostListening ? team.color : 'rgba(100,100,100,0.3)'}`, borderRadius: '4px', color: isHostListening ? team.color : '#666', fontSize: '10px', cursor: 'pointer', fontFamily: 'inherit' }}
                                >
                                  üéß {isHostListening ? 'ON' : 'OFF'}
                                </button>
                                <button
                                  onClick={() => { setHostSpeakChannel(prev => prev === team.id ? null : team.id); setAllCallActive(false); }}
                                  style={{ padding: '6px 10px', background: isHostSpeaking && !allCallActive ? `${team.color}33` : 'rgba(0,0,0,0.3)', border: `1px solid ${isHostSpeaking && !allCallActive ? team.color : 'rgba(100,100,100,0.3)'}`, borderRadius: '4px', color: isHostSpeaking && !allCallActive ? team.color : '#666', fontSize: '10px', cursor: 'pointer', fontFamily: 'inherit' }}
                                >
                                  üéôÔ∏è {isHostSpeaking && !allCallActive ? 'TX' : 'OFF'}
                                </button>
                              </>
                            )}
                            {isHostRef.current && (<button onClick={() => deleteTeam(team.id)} style={{ background: 'transparent', border: 'none', color: '#5a3a3a', fontSize: '18px', cursor: 'pointer', padding: '2px 8px' }} onMouseOver={(e) => e.target.style.color = '#ff4444'} onMouseOut={(e) => e.target.style.color = '#5a3a3a'}>√ó</button>)}
                          </div>
                        </div>

                        {/* Volume */}
                        <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '15px', padding: '10px 12px', background: 'rgba(0,0,0,0.3)', borderRadius: '6px' }}>
                          <span style={{ fontSize: '9px', color: '#6a8a6a' }}>VOL</span>
                          <input type="range" min="0" max="100" value={team.volume} onChange={(e) => updateVolume(team.id, parseInt(e.target.value))} style={{ flex: 1, height: '6px', appearance: 'none', background: `linear-gradient(to right, ${team.color} ${team.volume}%, rgba(100,100,100,0.3) ${team.volume}%)`, borderRadius: '3px', cursor: 'pointer' }} />
                          <span style={{ fontSize: '11px', color: team.color, minWidth: '35px', textAlign: 'right' }}>{team.volume}%</span>
                        </div>

                        {/* Channel Members */}
                        <div style={{ minHeight: '50px', padding: '10px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px', border: '1px dashed rgba(255,255,255,0.1)' }}>
                          {channelUsers.length === 0 ? (
                            <div style={{ textAlign: 'center', color: '#4a6a4a', fontSize: '11px', padding: '10px' }}>
                              {isHostRef.current ? 'Drag operators here' : 'No operators assigned'}
                            </div>
                          ) : (
                            <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                              {channelUsers.map(user => {
                                const status = statusConfig[user.status || 'standby'];
                                return (
                                  <div
                                    key={user.peerId}
                                    draggable={isHostRef.current}
                                    onDragStart={(e) => handleDragStart(e, user)}
                                    onDragEnd={() => setDraggedUser(null)}
                                    className={isHostRef.current ? 'user-chip' : ''}
                                    style={{ 
                                      display: 'flex', 
                                      alignItems: 'center', 
                                      gap: '8px', 
                                      padding: '8px 12px', 
                                      background: user.speaking ? 'rgba(0,255,100,0.2)' : 'rgba(0,0,0,0.4)', 
                                      border: `1px solid ${user.speaking ? 'rgba(0,255,100,0.5)' : 'rgba(255,255,255,0.1)'}`, 
                                      borderRadius: '6px',
                                      transition: 'all 0.2s'
                                    }}
                                  >
                                    <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: status.color, boxShadow: `0 0 6px ${status.color}`, animation: user.speaking ? 'pulse 0.5s infinite' : 'none' }} />
                                    <span style={{ fontSize: '11px', color: user.peerId === peerRef.current?.id ? '#00ff66' : '#e0ffe0' }}>
                                      {user.username.toUpperCase()}
                                      {user.peerId === peerRef.current?.id && <span style={{ fontSize: '9px', color: '#5a8a5a' }}> (YOU)</span>}
                                    </span>
                                    {user.speaking && (
                                      <div style={{ display: 'flex', gap: '2px', alignItems: 'flex-end', height: '12px' }}>
                                        {[1,2,3].map(i => (<div key={i} style={{ width: '2px', background: '#00ff66', borderRadius: '1px', animation: 'soundWave 0.5s infinite', animationDelay: `${i*0.1}s` }} />))}
                                      </div>
                                    )}
                                  </div>
                                );
                              })}
                            </div>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>

                {teams.length === 0 && (<div style={{ textAlign: 'center', padding: '50px', color: '#4a6a4a' }}><p style={{ fontSize: '13px', letterSpacing: '2px' }}>NO CHANNELS ‚Äî Commander must create channels</p></div>)}

                {/* Host indicator for listening to commander */}
                {connectedUsers.find(u => u.isHost && u.speaking) && !isHostRef.current && (
                  <div style={{ position: 'fixed', bottom: '20px', left: '50%', transform: 'translateX(-50%)', background: 'rgba(255,200,0,0.2)', border: '2px solid rgba(255,200,0,0.6)', borderRadius: '10px', padding: '12px 24px', zIndex: 2000 }}>
                    <span style={{ fontSize: '12px', letterSpacing: '2px', color: '#ffcc00' }}>
                      üì¢ COMMANDER {connectedUsers.find(u => u.isHost)?.speakingToAll ? 'ALL-CALL' : 'TRANSMITTING'}
                    </span>
                  </div>
                )}
              </>
            )}
          </div>

          {/* Create Modal */}
          {showCreateModal && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }} onClick={() => setShowCreateModal(false)}>
              <div style={{ background: 'linear-gradient(135deg, #0f1f0f, #1a2a1a)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '16px', padding: '35px', width: '380px', maxWidth: '90vw' }} onClick={(e) => e.stopPropagation()}>
                <h3 style={{ margin: '0 0 25px 0', fontSize: '14px', letterSpacing: '4px', textAlign: 'center' }}>NEW CHANNEL</h3>
                <input type="text" value={newTeamName} onChange={(e) => setNewTeamName(e.target.value)} placeholder="Channel name..." autoFocus style={{ width: '100%', padding: '14px 18px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '14px', outline: 'none', fontFamily: 'inherit', marginBottom: '18px' }} onKeyDown={(e) => e.key === 'Enter' && createTeam()} />
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '2px', color: '#6a9a6a', marginBottom: '10px' }}>COLOR</label>
                  <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                    {colorOptions.map(color => (<div key={color} onClick={() => setNewTeamColor(color)} style={{ width: '28px', height: '28px', borderRadius: '6px', background: color, cursor: 'pointer', border: newTeamColor === color ? '3px solid white' : '3px solid transparent', boxShadow: newTeamColor === color ? `0 0 15px ${color}` : 'none' }} />))}
                  </div>
                </div>
                <div style={{ display: 'flex', gap: '10px' }}>
                  <button onClick={() => setShowCreateModal(false)} style={{ flex: 1, padding: '12px', background: 'transparent', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '6px', color: '#888', fontSize: '11px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>CANCEL</button>
                  <button onClick={createTeam} style={{ flex: 1, padding: '12px', background: `${newTeamColor}33`, border: `1px solid ${newTeamColor}88`, borderRadius: '6px', color: newTeamColor, fontSize: '11px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>CREATE</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<VoIPApp />);
  </script>
</body>
</html>
