<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>G-COMMS | GBRS Communications System v.0.9.3</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üì°</text></svg>">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      background: linear-gradient(135deg, #0a0f0a 0%, #1a1f1a 50%, #0f1a0f 100%);
      min-height: 100vh;
      color: #e0ffe0;
    }
    ::placeholder { color: #4a6a4a; }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none; width: 14px; height: 14px; border-radius: 50%;
      background: #e0ffe0; cursor: pointer; box-shadow: 0 0 10px rgba(0,255,100,0.5);
    }
    input[type="range"]::-moz-range-thumb {
      width: 14px; height: 14px; border-radius: 50%; background: #e0ffe0;
      cursor: pointer; border: none; box-shadow: 0 0 10px rgba(0,255,100,0.5);
    }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } }
    @keyframes glow { 0%, 100% { box-shadow: 0 0 20px rgba(0,255,100,0.2); } 50% { box-shadow: 0 0 30px rgba(0,255,100,0.4); } }
    @keyframes flashAlert { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes soundWave { 0%, 100% { height: 4px; } 50% { height: 16px; } }
    .user-chip { cursor: grab; user-select: none; transition: all 0.2s; }
    .user-chip:active { cursor: grabbing; }
    .channel-drop-zone { transition: all 0.2s; }
    .channel-drop-zone.drag-over { background: rgba(0,255,100,0.1); border-color: rgba(0,255,100,0.5) !important; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    const COMMAND_NET_ID = 'command-net';

    const VoIPApp = () => {
      const [sessionState, setSessionState] = useState('lobby');
      const [sessionCode, setSessionCode] = useState('');
      const [joinCode, setJoinCode] = useState('');
      const [username, setUsername] = useState('');
      const [error, setError] = useState('');
      const [connectedUsers, setConnectedUsers] = useState([]);
      const [myStatus, setMyStatus] = useState('standby');
      const [myChannelId, setMyChannelId] = useState(null);
      const [myRole, setMyRole] = useState('operator'); // operator, squadleader, commander
      
      const [teams, setTeams] = useState([
        { id: 1, name: 'Alpha Squad', volume: 80, color: '#00ff66' },
        { id: 2, name: 'Bravo Unit', volume: 80, color: '#ffcc00' },
      ]);
      const [newTeamName, setNewTeamName] = useState('');
      const [newTeamColor, setNewTeamColor] = useState('#00ff66');
      const [showCreateModal, setShowCreateModal] = useState(false);
      
      // Channel audio states - keyed by channel ID
      const [channelStates, setChannelStates] = useState({});
      // { channelId: { listen: bool, speak: bool }, ... }
      
      const [audioLevel, setAudioLevel] = useState(0);
      const [globalMute, setGlobalMute] = useState(false);
      const [whistleActive, setWhistleActive] = useState(false);
      const [incomingWhistle, setIncomingWhistle] = useState(null);
      const [draggedUser, setDraggedUser] = useState(null);
      const [commandNetVolume, setCommandNetVolume] = useState(80);
      
      const peerRef = useRef(null);
      const connectionsRef = useRef(new Map());
      const localStreamRef = useRef(null);
      const audioContextRef = useRef(null);
      const analyserRef = useRef(null);
      const animationRef = useRef(null);
      const isHostRef = useRef(false);
      const audioElementsRef = useRef(new Map()); // peerId -> Audio element
      const teamsRef = useRef(teams);
      const myStatusRef = useRef(myStatus);
      const myChannelIdRef = useRef(myChannelId);
      const myRoleRef = useRef(myRole);
      const connectedUsersRef = useRef(connectedUsers);
      const channelStatesRef = useRef(channelStates);

      useEffect(() => { teamsRef.current = teams; }, [teams]);
      useEffect(() => { myStatusRef.current = myStatus; }, [myStatus]);
      useEffect(() => { myChannelIdRef.current = myChannelId; }, [myChannelId]);
      useEffect(() => { myRoleRef.current = myRole; }, [myRole]);
      useEffect(() => { connectedUsersRef.current = connectedUsers; }, [connectedUsers]);
      useEffect(() => { channelStatesRef.current = channelStates; }, [channelStates]);

      // Check if currently speaking on any channel
      const isSpeaking = !globalMute && Object.values(channelStates).some(s => s.speak);
      
      // Get channels I'm speaking to
      const getSpeakingChannels = useCallback(() => {
        if (globalMute) return [];
        return Object.entries(channelStates)
          .filter(([_, state]) => state.speak)
          .map(([id, _]) => id === COMMAND_NET_ID ? COMMAND_NET_ID : parseInt(id));
      }, [channelStates, globalMute]);

      const colorOptions = [
        '#00ff66', '#ffcc00', '#ff6b6b', '#4ecdc4', '#a855f7', 
        '#3b82f6', '#f97316', '#ec4899', '#84cc16', '#06b6d4'
      ];

      const statusConfig = {
        standby: { color: '#666666', label: 'STANDBY', icon: '‚ö´' },
        ready: { color: '#00ff66', label: 'READY', icon: 'üü¢' },
        dead: { color: '#ff4444', label: 'DOWN', icon: 'üî¥' },
        wait: { color: '#ffaa00', label: 'WAIT ONE', icon: 'üü°' }
      };

      const roleConfig = {
        operator: { label: 'OPERATOR', color: '#00ff66', icon: '‚óè' },
        squadleader: { label: 'SQUAD LEADER', color: '#4ecdc4', icon: '‚óÜ' },
        commander: { label: 'COMMANDER', color: '#ffcc00', icon: '‚òÖ' }
      };

      // Check if user can see command net
      const canSeeCommandNet = (role) => role === 'commander' || role === 'squadleader';

      // Get channels visible to current user
      const getVisibleChannels = () => {
        if (myRole === 'commander') {
          return teams; // Commander sees all squad channels
        } else if (myRole === 'squadleader') {
          return teams.filter(t => t.id === myChannelId); // Squad leader sees their squad
        } else {
          return teams.filter(t => t.id === myChannelId); // Operator sees their squad
        }
      };

      // Update audio routing - determines who we hear
      const updateAudioRouting = useCallback(() => {
        console.log('Updating audio routing, users:', connectedUsersRef.current.length);
        
        connectedUsersRef.current.forEach(user => {
          if (user.peerId === peerRef.current?.id) return;
          
          const audioEl = audioElementsRef.current.get(user.peerId);
          if (!audioEl) {
            console.log('No audio element for', user.username);
            return;
          }
          
          let shouldHear = false;
          let volume = 0.8;
          
          // Check if we should hear this user based on their speaking channels and our listening channels
          if (user.speaking && user.speakingChannels && user.speakingChannels.length > 0) {
            console.log(user.username, 'is speaking on channels:', user.speakingChannels);
            console.log('My channel states:', channelStatesRef.current);
            
            for (const speakingCh of user.speakingChannels) {
              // Check both string and number versions of channel ID
              const chState = channelStatesRef.current[speakingCh] || channelStatesRef.current[String(speakingCh)];
              console.log('Checking channel', speakingCh, 'state:', chState);
              
              if (chState?.listen) {
                shouldHear = true;
                // Get volume for this channel
                if (speakingCh === COMMAND_NET_ID) {
                  volume = commandNetVolume / 100;
                } else {
                  const team = teamsRef.current.find(t => t.id === speakingCh || t.id === parseInt(speakingCh));
                  if (team) volume = team.volume / 100;
                }
                break;
              }
            }
          }
          
          if (globalMute) shouldHear = false;
          
          console.log('Should hear', user.username, ':', shouldHear, 'volume:', volume);
          audioEl.muted = !shouldHear;
          audioEl.volume = volume;
        });
      }, [globalMute, commandNetVolume]);

      useEffect(() => {
        updateAudioRouting();
      }, [connectedUsers, channelStates, globalMute, teams, updateAudioRouting]);

      const broadcastStatus = useCallback((newStatus) => {
        setMyStatus(newStatus);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'status-update', peerId: peerRef.current?.id, status: newStatus });
          }
        });
      }, []);

      const broadcastSpeakingState = useCallback((speakingChannels) => {
        console.log('Broadcasting speaking state, channels:', speakingChannels);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ 
              type: 'speaking-update', 
              peerId: peerRef.current?.id, 
              speaking: speakingChannels.length > 0,
              speakingChannels: speakingChannels
            });
          }
        });
      }, []);

      useEffect(() => {
        if (sessionState !== 'lobby') {
          const channels = getSpeakingChannels();
          broadcastSpeakingState(channels);
        }
      }, [channelStates, sessionState, globalMute, getSpeakingChannels, broadcastSpeakingState]);

      // Toggle channel listen/speak
      const toggleChannelListen = (channelId) => {
        setChannelStates(prev => ({
          ...prev,
          [channelId]: { ...prev[channelId], listen: !prev[channelId]?.listen }
        }));
      };

      const toggleChannelSpeak = (channelId) => {
        setChannelStates(prev => ({
          ...prev,
          [channelId]: { ...prev[channelId], speak: !prev[channelId]?.speak }
        }));
      };

      // Promote user to squad leader (host only)
      const promoteToSquadLeader = useCallback((userId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, role: 'squadleader' } : u
        ));
        
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'role-update', peerId: userId, role: 'squadleader' });
          }
        });
      }, []);

      // Demote squad leader to operator (host only)
      const demoteToOperator = useCallback((userId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, role: 'operator' } : u
        ));
        
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'role-update', peerId: userId, role: 'operator' });
          }
        });
      }, []);

      // Move user to channel (host only)
      const moveUserToChannel = useCallback((userId, channelId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, channelId } : u
        ));
        
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'user-moved', peerId: userId, channelId });
          }
        });
        
        if (userId === peerRef.current?.id) {
          setMyChannelId(channelId);
        }
      }, []);

      const playWhistle = useCallback((type = 'attention') => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        if (type === 'attention') {
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(800, ctx.currentTime);
          oscillator.frequency.linearRampToValueAtTime(1600, ctx.currentTime + 0.3);
          oscillator.frequency.linearRampToValueAtTime(1200, ctx.currentTime + 0.6);
          gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
          gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.7);
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.7);
        } else if (type === 'alert') {
          oscillator.type = 'square';
          oscillator.frequency.setValueAtTime(1000, ctx.currentTime);
          gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
          gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.1);
          gainNode.gain.setValueAtTime(0.2, ctx.currentTime + 0.15);
          gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.25);
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.3);
        } else if (type === 'urgent') {
          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(1200, ctx.currentTime);
          gainNode.gain.setValueAtTime(0.15, ctx.currentTime);
          for (let i = 0; i < 3; i++) {
            const t = ctx.currentTime + i * 0.15;
            gainNode.gain.setValueAtTime(0.15, t);
            gainNode.gain.setValueAtTime(0, t + 0.1);
          }
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.5);
        }
      }, []);

      const broadcastWhistle = useCallback((type) => {
        playWhistle(type);
        setWhistleActive(true);
        setTimeout(() => setWhistleActive(false), 800);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) connData.conn.send({ type: 'whistle', whistleType: type, from: username });
        });
      }, [playWhistle, username]);

      // Hotkeys
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (sessionState === 'lobby') return;
          if (e.target.tagName === 'INPUT') return;
          
          if (e.ctrlKey && e.shiftKey && (e.key === 'A' || e.key === 'a')) {
            e.preventDefault(); broadcastStatus('ready'); return;
          }
          if (e.ctrlKey && e.altKey && (e.key === 'd' || e.key === 'D')) {
            e.preventDefault(); broadcastStatus('dead'); return;
          }
          if (e.ctrlKey && e.altKey && (e.key === 'w' || e.key === 'W')) {
            e.preventDefault(); broadcastStatus('wait'); return;
          }
          if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'm') {
            e.preventDefault(); setGlobalMute(prev => !prev); return;
          }
          if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'w') {
            e.preventDefault(); broadcastWhistle('attention'); return;
          }
          // Ctrl+0 - Toggle Command Net speak (if visible)
          if (e.ctrlKey && e.key === '0' && canSeeCommandNet(myRoleRef.current)) {
            e.preventDefault();
            toggleChannelSpeak(COMMAND_NET_ID);
            return;
          }
          // Ctrl+` - Toggle Command Net listen (if visible)
          if (e.ctrlKey && e.key === '`' && canSeeCommandNet(myRoleRef.current)) {
            e.preventDefault();
            toggleChannelListen(COMMAND_NET_ID);
            return;
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [sessionState, broadcastWhistle, broadcastStatus]);

      const generateCode = () => {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
        return code;
      };

      const initPeer = useCallback((peerId) => {
        return new Promise((resolve, reject) => {
          const peer = new Peer(peerId, { debug: 1 });
          peer.on('open', (id) => { console.log('Connected:', id); resolve(peer); });
          peer.on('error', (err) => {
            if (err.type === 'unavailable-id') reject(new Error('Session code already in use'));
            else if (err.type === 'peer-unavailable') reject(new Error('Session not found'));
            else reject(err);
          });
          peerRef.current = peer;
        });
      }, []);

      const getLocalStream = useCallback(async () => {
        if (!localStreamRef.current) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
              audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } 
            });
            localStreamRef.current = stream;
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
            analyserRef.current = audioContextRef.current.createAnalyser();
            const source = audioContextRef.current.createMediaStreamSource(stream);
            source.connect(analyserRef.current);
            analyserRef.current.fftSize = 256;
            return stream;
          } catch (err) {
            setError('Microphone access required');
            return null;
          }
        }
        return localStreamRef.current;
      }, []);

      useEffect(() => {
        if (isSpeaking && analyserRef.current) {
          const updateLevel = () => {
            const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
            analyserRef.current.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
            setAudioLevel(avg / 255);
            animationRef.current = requestAnimationFrame(updateLevel);
          };
          updateLevel();
        } else {
          if (animationRef.current) cancelAnimationFrame(animationRef.current);
          setAudioLevel(0);
        }
        return () => { if (animationRef.current) cancelAnimationFrame(animationRef.current); };
      }, [isSpeaking]);

      useEffect(() => {
        if (localStreamRef.current) {
          const tracks = localStreamRef.current.getAudioTracks();
          tracks.forEach(track => { 
            track.enabled = isSpeaking;
            console.log('Mic track enabled:', isSpeaking);
          });
        }
      }, [isSpeaking]);

      const handleData = useCallback((data, fromPeerId) => {
        console.log('Received:', data.type, 'from:', fromPeerId);
        
        if (data.type === 'whistle') {
          playWhistle(data.whistleType);
          setIncomingWhistle({ type: data.whistleType, from: data.from });
          setTimeout(() => setIncomingWhistle(null), 2000);
        } else if (data.type === 'status-update') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, status: data.status } : u));
        } else if (data.type === 'speaking-update') {
          console.log('Received speaking update:', data.peerId, 'speaking:', data.speaking, 'channels:', data.speakingChannels);
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { 
            ...u, 
            speaking: data.speaking,
            speakingChannels: data.speakingChannels || []
          } : u));
        } else if (data.type === 'role-update') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, role: data.role } : u));
          if (data.peerId === peerRef.current?.id) {
            setMyRole(data.role);
            // If promoted to squad leader, enable command net listening by default
            if (data.role === 'squadleader') {
              setChannelStates(prev => ({
                ...prev,
                [COMMAND_NET_ID]: { listen: true, speak: false }
              }));
            }
          }
        } else if (data.type === 'user-moved') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, channelId: data.channelId } : u));
          if (data.peerId === peerRef.current?.id) {
            setMyChannelId(data.channelId);
            // Enable listen/speak on assigned channel
            setChannelStates(prev => ({
              ...prev,
              [data.channelId]: { listen: true, speak: true }
            }));
          }
        } else if (data.type === 'user-joined') {
          setConnectedUsers(prev => {
            if (!prev.find(u => u.peerId === data.peerId)) {
              return [...prev, { 
                peerId: data.peerId, 
                username: data.username, 
                status: data.status || 'standby', 
                speaking: data.speaking || false,
                speakingChannels: data.speakingChannels || [],
                channelId: data.channelId || null,
                role: data.role || 'operator',
                isHost: data.isHost || false
              }];
            }
            return prev;
          });
          
          if (isHostRef.current) {
            const conn = connectionsRef.current.get(fromPeerId)?.conn;
            if (conn?.open) {
              const defaultChannel = teamsRef.current.length > 0 ? teamsRef.current[0].id : null;
              const newUser = { 
                peerId: data.peerId, 
                username: data.username, 
                status: data.status || 'standby',
                speaking: false,
                speakingChannels: [],
                channelId: defaultChannel,
                role: 'operator',
                isHost: false
              };
              const allUsers = [...connectedUsersRef.current.filter(u => u.peerId !== data.peerId), newUser];
              conn.send({
                type: 'sync-state',
                teams: teamsRef.current,
                users: allUsers.map(u => ({
                  ...u,
                  speaking: u.speaking || false,
                  speakingChannels: u.speakingChannels || []
                })),
                yourChannelId: defaultChannel,
                yourRole: 'operator'
              });
            }
            connectionsRef.current.forEach((connData, peerId) => {
              if (peerId !== fromPeerId && connData.conn?.open) {
                connData.conn.send({ 
                  type: 'user-joined', 
                  peerId: data.peerId, 
                  username: data.username, 
                  status: data.status || 'standby',
                  speaking: false,
                  speakingChannels: [],
                  channelId: teamsRef.current.length > 0 ? teamsRef.current[0].id : null,
                  role: 'operator',
                  isHost: false
                });
              }
            });
          }
        } else if (data.type === 'sync-state') {
          setTeams(data.teams);
          // Ensure all users have required fields
          const usersWithDefaults = data.users.map(u => ({
            ...u,
            speaking: u.speaking || false,
            speakingChannels: u.speakingChannels || [],
            status: u.status || 'standby',
            role: u.role || 'operator'
          }));
          setConnectedUsers(usersWithDefaults);
          setMyChannelId(data.yourChannelId);
          setMyRole(data.yourRole || 'operator');
          // Set up initial channel states
          if (data.yourChannelId) {
            setChannelStates(prev => ({
              ...prev,
              [data.yourChannelId]: { listen: true, speak: true }
            }));
          }
        } else if (data.type === 'teams-update') {
          setTeams(data.teams);
        } else if (data.type === 'user-left') {
          setConnectedUsers(prev => prev.filter(u => u.peerId !== data.peerId));
        }
      }, [playWhistle]);

      const setupConnection = useCallback((conn) => {
        conn.on('open', async () => {
          console.log('Connection opened:', conn.peer);
          connectionsRef.current.set(conn.peer, { ...connectionsRef.current.get(conn.peer), conn });
          conn.send({ 
            type: 'user-joined', 
            peerId: peerRef.current.id, 
            username: username, 
            status: myStatusRef.current,
            channelId: myChannelIdRef.current,
            role: myRoleRef.current,
            isHost: isHostRef.current
          });
          const stream = await getLocalStream();
          if (stream && peerRef.current) {
            const call = peerRef.current.call(conn.peer, stream);
            setupCall(call);
          }
        });
        conn.on('data', (data) => handleData(data, conn.peer));
        conn.on('close', () => {
          console.log('Connection closed:', conn.peer);
          const audioEl = audioElementsRef.current.get(conn.peer);
          if (audioEl) {
            audioEl.srcObject = null;
            audioEl.remove();
            audioElementsRef.current.delete(conn.peer);
          }
          connectionsRef.current.delete(conn.peer);
          setConnectedUsers(prev => prev.filter(u => u.peerId !== conn.peer));
        });
      }, [username, getLocalStream, handleData]);

      const setupCall = useCallback((call) => {
        call.on('stream', (remoteStream) => {
          console.log('Got audio stream from:', call.peer);
          
          // Create or get audio element for this peer
          let audioEl = audioElementsRef.current.get(call.peer);
          if (!audioEl) {
            audioEl = new Audio();
            audioEl.autoplay = true;
            audioEl.muted = true; // Start muted, updateAudioRouting will unmute if needed
            audioElementsRef.current.set(call.peer, audioEl);
          }
          
          audioEl.srcObject = remoteStream;
          audioEl.play().catch(e => console.log('Audio play error:', e));
          
          connectionsRef.current.set(call.peer, { ...connectionsRef.current.get(call.peer), stream: remoteStream });
          
          // Trigger routing update after a short delay
          setTimeout(() => updateAudioRouting(), 100);
        });
        
        call.on('error', (err) => {
          console.error('Call error:', err);
        });
      }, [updateAudioRouting]);

      const hostSession = async () => {
        if (!username.trim()) { setError('Please enter your callsign'); return; }
        setError('');
        const code = generateCode();
        try {
          const peer = await initPeer(`gcomms-${code}-host`);
          peer.on('connection', (conn) => { console.log('Incoming:', conn.peer); setupConnection(conn); });
          peer.on('call', async (call) => {
            const stream = await getLocalStream();
            if (stream) { call.answer(stream); setupCall(call); }
          });
          isHostRef.current = true;
          setSessionCode(code);
          setSessionState('hosting');
          setMyRole('commander');
          // Commander starts with command net and all channels listen enabled
          const initialStates = { [COMMAND_NET_ID]: { listen: true, speak: false } };
          teams.forEach(t => { initialStates[t.id] = { listen: true, speak: false }; });
          setChannelStates(initialStates);
          setConnectedUsers([{ 
            peerId: peer.id, 
            username: username, 
            isHost: true, 
            status: 'standby', 
            speaking: false,
            speakingChannels: [],
            channelId: null,
            role: 'commander'
          }]);
        } catch (err) { setError(err.message); }
      };

      const joinSession = async () => {
        if (!username.trim()) { setError('Please enter your callsign'); return; }
        if (!joinCode.trim()) { setError('Please enter a session code'); return; }
        setError('');
        const code = joinCode.toUpperCase().replace(/[^A-Z0-9]/g, '');
        const uniqueId = `gcomms-${code}-${Date.now()}`;
        try {
          const peer = await initPeer(uniqueId);
          peer.on('connection', (conn) => setupConnection(conn));
          peer.on('call', async (call) => {
            const stream = await getLocalStream();
            if (stream) { call.answer(stream); setupCall(call); }
          });
          const hostPeerId = `gcomms-${code}-host`;
          const conn = peer.connect(hostPeerId, { reliable: true });
          conn.on('error', () => setError('Failed to connect'));
          setupConnection(conn);
          isHostRef.current = false;
          setSessionCode(code);
          setSessionState('joined');
          setMyRole('operator');
          setConnectedUsers([{ peerId: peer.id, username: username, status: 'standby', speaking: false, speakingChannels: [], channelId: null, role: 'operator' }]);
        } catch (err) { setError(err.message); }
      };

      const leaveSession = () => {
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'user-left', peerId: peerRef.current?.id });
            connData.conn.close();
          }
        });
        connectionsRef.current.clear();
        // Clean up audio elements
        audioElementsRef.current.forEach(audioEl => {
          audioEl.srcObject = null;
          audioEl.remove();
        });
        audioElementsRef.current.clear();
        if (localStreamRef.current) { localStreamRef.current.getTracks().forEach(track => track.stop()); localStreamRef.current = null; }
        if (peerRef.current) { peerRef.current.destroy(); peerRef.current = null; }
        setSessionState('lobby');
        setSessionCode('');
        setConnectedUsers([]);
        setMyChannelId(null);
        setMyRole('operator');
        setMyStatus('standby');
        setChannelStates({});
        isHostRef.current = false;
      };

      const syncTeams = (newTeams) => {
        if (isHostRef.current) {
          connectionsRef.current.forEach((connData) => {
            if (connData.conn?.open) connData.conn.send({ type: 'teams-update', teams: newTeams });
          });
        }
      };

      const createTeam = () => {
        if (newTeamName.trim()) {
          const newTeam = { id: Date.now(), name: newTeamName.trim(), volume: 80, color: newTeamColor };
          const newTeams = [...teams, newTeam];
          setTeams(newTeams);
          setChannelStates(prev => ({ ...prev, [newTeam.id]: { listen: true, speak: false } }));
          setNewTeamName('');
          setNewTeamColor('#00ff66');
          setShowCreateModal(false);
          syncTeams(newTeams);
        }
      };

      const deleteTeam = (id) => {
        setConnectedUsers(prev => prev.map(u => u.channelId === id ? { ...u, channelId: null } : u));
        const newTeams = teams.filter(t => t.id !== id);
        setTeams(newTeams);
        setChannelStates(prev => { const n = { ...prev }; delete n[id]; return n; });
        syncTeams(newTeams);
      };

      const copyCode = () => navigator.clipboard.writeText(sessionCode);

      useEffect(() => {
        const speakingChannels = getSpeakingChannels();
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === peerRef.current?.id 
            ? { ...u, status: myStatus, speaking: isSpeaking, speakingChannels: speakingChannels } 
            : u
        ));
      }, [myStatus, isSpeaking, getSpeakingChannels]);

      // Drag and drop
      const handleDragStart = (e, user) => { if (isHostRef.current) setDraggedUser(user); };
      const handleDragOver = (e) => { if (isHostRef.current && draggedUser) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; } };
      const handleDragEnter = (e) => { if (isHostRef.current && draggedUser) e.currentTarget.classList.add('drag-over'); };
      const handleDragLeave = (e) => { e.currentTarget.classList.remove('drag-over'); };
      const handleDrop = (e, channelId) => {
        e.preventDefault();
        e.currentTarget.classList.remove('drag-over');
        if (isHostRef.current && draggedUser && !draggedUser.isHost) {
          moveUserToChannel(draggedUser.peerId, channelId);
        }
        setDraggedUser(null);
      };

      const getUsersInChannel = (channelId) => connectedUsers.filter(u => u.channelId === channelId && !u.isHost);
      const getUnassignedUsers = () => connectedUsers.filter(u => u.channelId === null && !u.isHost);
      const getCommandNetUsers = () => connectedUsers.filter(u => u.role === 'commander' || u.role === 'squadleader');

      // Channel card component
      const ChannelCard = ({ channel, isCommandNet = false }) => {
        const channelId = isCommandNet ? COMMAND_NET_ID : channel.id;
        const channelState = channelStates[channelId] || { listen: false, speak: false };
        const channelUsers = isCommandNet ? getCommandNetUsers() : getUsersInChannel(channel.id);
        const channelColor = isCommandNet ? '#ff6b6b' : channel.color;
        const channelName = isCommandNet ? 'COMMAND NET' : channel.name;
        
        return (
          <div
            className={!isCommandNet ? "channel-drop-zone" : ""}
            onDragOver={!isCommandNet ? handleDragOver : undefined}
            onDragEnter={!isCommandNet ? handleDragEnter : undefined}
            onDragLeave={!isCommandNet ? handleDragLeave : undefined}
            onDrop={!isCommandNet ? (e) => handleDrop(e, channel.id) : undefined}
            style={{ 
              background: isCommandNet 
                ? 'linear-gradient(135deg, rgba(40,15,15,0.9), rgba(50,20,20,0.9))' 
                : 'linear-gradient(135deg, rgba(10,30,10,0.9), rgba(20,40,20,0.9))', 
              border: `2px solid ${channelState.speak ? channelColor : channelState.listen ? `${channelColor}66` : 'rgba(255,255,255,0.15)'}`,
              borderRadius: '12px', 
              padding: '18px',
              boxShadow: channelState.speak ? `0 0 30px ${channelColor}33` : 'none',
              marginBottom: '15px'
            }}
          >
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                <div style={{ width: '16px', height: '16px', borderRadius: '50%', background: channelColor, boxShadow: `0 0 10px ${channelColor}66` }} />
                <div>
                  <h2 style={{ margin: 0, fontSize: '15px', fontWeight: '500', letterSpacing: '2px', color: channelColor }}>
                    {isCommandNet ? 'üì° ' : ''}{channelName.toUpperCase()}
                  </h2>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}>
                    {isCommandNet ? 'LEADERSHIP ONLY' : `${channelUsers.length} OPERATORS`}
                    {isCommandNet && ' ‚Ä¢ Ctrl+` Listen ‚Ä¢ Ctrl+0 Speak'}
                  </span>
                </div>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                <button
                  onClick={() => toggleChannelListen(channelId)}
                  style={{ padding: '8px 12px', background: channelState.listen ? `${channelColor}33` : 'rgba(0,0,0,0.3)', border: `1px solid ${channelState.listen ? channelColor : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: channelState.listen ? channelColor : '#666', fontSize: '11px', cursor: 'pointer', fontFamily: 'inherit', display: 'flex', alignItems: 'center', gap: '6px' }}
                >
                  üéß {channelState.listen ? 'ON' : 'OFF'}
                </button>
                <button
                  onClick={() => toggleChannelSpeak(channelId)}
                  style={{ padding: '8px 12px', background: channelState.speak ? `${channelColor}33` : 'rgba(0,0,0,0.3)', border: `1px solid ${channelState.speak ? channelColor : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: channelState.speak ? channelColor : '#666', fontSize: '11px', cursor: 'pointer', fontFamily: 'inherit', display: 'flex', alignItems: 'center', gap: '6px', animation: channelState.speak ? 'pulse 1s infinite' : 'none' }}
                >
                  üéôÔ∏è {channelState.speak ? 'TX' : 'OFF'}
                </button>
                {!isCommandNet && isHostRef.current && (
                  <button onClick={() => deleteTeam(channel.id)} style={{ background: 'transparent', border: 'none', color: '#5a3a3a', fontSize: '18px', cursor: 'pointer', padding: '2px 8px' }} onMouseOver={(e) => e.target.style.color = '#ff4444'} onMouseOut={(e) => e.target.style.color = '#5a3a3a'}>√ó</button>
                )}
              </div>
            </div>

            {/* Channel Members */}
            <div style={{ minHeight: '40px', padding: '10px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px', border: '1px dashed rgba(255,255,255,0.1)' }}>
              {channelUsers.length === 0 ? (
                <div style={{ textAlign: 'center', color: '#4a6a4a', fontSize: '11px', padding: '5px' }}>
                  {isCommandNet ? 'No leadership online' : (isHostRef.current ? 'Drag operators here' : 'No operators')}
                </div>
              ) : (
                <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                  {channelUsers.map(user => {
                    const status = statusConfig[user.status || 'standby'];
                    const role = roleConfig[user.role || 'operator'];
                    const isSpeakingHere = user.speaking && user.speakingChannels?.includes(channelId);
                    return (
                      <div
                        key={user.peerId}
                        draggable={isHostRef.current && !user.isHost && !isCommandNet}
                        onDragStart={(e) => handleDragStart(e, user)}
                        onDragEnd={() => setDraggedUser(null)}
                        className={isHostRef.current && !user.isHost && !isCommandNet ? 'user-chip' : ''}
                        style={{ 
                          display: 'flex', 
                          alignItems: 'center', 
                          gap: '8px', 
                          padding: '8px 12px', 
                          background: isSpeakingHere ? 'rgba(0,255,100,0.2)' : 'rgba(0,0,0,0.4)', 
                          border: `1px solid ${isSpeakingHere ? 'rgba(0,255,100,0.5)' : 'rgba(255,255,255,0.1)'}`, 
                          borderRadius: '6px',
                          position: 'relative'
                        }}
                      >
                        <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: status.color, boxShadow: `0 0 6px ${status.color}`, animation: isSpeakingHere ? 'pulse 0.5s infinite' : 'none' }} />
                        <div>
                          <div style={{ fontSize: '11px', color: user.peerId === peerRef.current?.id ? '#00ff66' : '#e0ffe0', display: 'flex', alignItems: 'center', gap: '4px' }}>
                            <span style={{ color: role.color }}>{role.icon}</span>
                            {user.username.toUpperCase()}
                            {user.peerId === peerRef.current?.id && <span style={{ fontSize: '9px', color: '#5a8a5a' }}>(YOU)</span>}
                          </div>
                          {isHostRef.current && !user.isHost && !isCommandNet && (
                            <div style={{ fontSize: '8px', marginTop: '2px' }}>
                              {user.role === 'squadleader' ? (
                                <span onClick={() => demoteToOperator(user.peerId)} style={{ color: '#ff6666', cursor: 'pointer' }}>DEMOTE</span>
                              ) : (
                                <span onClick={() => promoteToSquadLeader(user.peerId)} style={{ color: '#4ecdc4', cursor: 'pointer' }}>‚Üí SQUAD LEADER</span>
                              )}
                            </div>
                          )}
                        </div>
                        {isSpeakingHere && (
                          <div style={{ display: 'flex', gap: '2px', alignItems: 'flex-end', height: '12px' }}>
                            {[1,2,3].map(i => (<div key={i} style={{ width: '2px', background: '#00ff66', borderRadius: '1px', animation: 'soundWave 0.5s infinite', animationDelay: `${i*0.1}s` }} />))}
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          </div>
        );
      };

      return (
        <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #0a0f0a 0%, #1a1f1a 50%, #0f1a0f 100%)', fontFamily: '"JetBrains Mono", monospace', color: '#e0ffe0', padding: '40px 20px', position: 'relative', overflow: 'hidden' }}>
          <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 4px)', pointerEvents: 'none', zIndex: 1000 }} />
          <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, backgroundImage: 'linear-gradient(rgba(0,255,100,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,100,0.03) 1px, transparent 1px)', backgroundSize: '50px 50px', pointerEvents: 'none' }} />

          {incomingWhistle && (
            <div style={{ position: 'fixed', top: '20px', left: '50%', transform: 'translateX(-50%)', background: 'rgba(255,200,0,0.2)', border: '2px solid rgba(255,200,0,0.6)', borderRadius: '10px', padding: '15px 30px', zIndex: 2000, animation: 'flashAlert 0.3s ease-in-out infinite' }}>
              <span style={{ fontSize: '13px', letterSpacing: '2px', color: '#ffcc00' }}>‚ö†Ô∏è {incomingWhistle.from.toUpperCase()} ‚Äî {incomingWhistle.type.toUpperCase()} SIGNAL</span>
            </div>
          )}

          <div style={{ maxWidth: '1000px', margin: '0 auto', position: 'relative', zIndex: 1 }}>
            {/* Header */}
            <div style={{ textAlign: 'center', marginBottom: '35px' }}>
              <div style={{ display: 'inline-flex', alignItems: 'center', gap: '15px', marginBottom: '8px' }}>
                <div style={{ width: '12px', height: '12px', borderRadius: '50%', background: sessionState !== 'lobby' ? '#00ff66' : '#ff6600', boxShadow: sessionState !== 'lobby' ? '0 0 20px #00ff66' : '0 0 10px #ff6600', animation: sessionState !== 'lobby' ? 'pulse 2s infinite' : 'none' }} />
                <h1 style={{ fontSize: '38px', fontWeight: '300', letterSpacing: '6px', margin: 0, textShadow: '0 0 30px rgba(0,255,100,0.3)' }}>G-COMMS</h1>
                <div style={{ width: '12px', height: '12px', borderRadius: '50%', background: sessionState !== 'lobby' ? '#00ff66' : '#ff6600', boxShadow: sessionState !== 'lobby' ? '0 0 20px #00ff66' : '0 0 10px #ff6600', animation: sessionState !== 'lobby' ? 'pulse 2s infinite' : 'none' }} />
              </div>
              <p style={{ fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', margin: 0 }}>GBRS COMMUNICATIONS SYSTEM v.0.9.3</p>
            </div>

            {/* Lobby */}
            {sessionState === 'lobby' && (
              <div style={{ maxWidth: '450px', margin: '0 auto' }}>
                <div style={{ marginBottom: '30px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', marginBottom: '10px' }}>YOUR CALLSIGN</label>
                  <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} placeholder="Enter callsign..." style={{ width: '100%', padding: '15px 20px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '16px', outline: 'none', fontFamily: 'inherit' }} />
                </div>
                {error && <div style={{ padding: '12px', background: 'rgba(255,50,50,0.1)', border: '1px solid rgba(255,50,50,0.3)', borderRadius: '6px', color: '#ff6666', fontSize: '12px', marginBottom: '20px', textAlign: 'center' }}>{error}</div>}
                <button onClick={hostSession} style={{ width: '100%', padding: '20px', marginBottom: '15px', background: 'linear-gradient(135deg, rgba(0,255,100,0.15), rgba(0,200,80,0.1))', border: '2px solid rgba(0,255,100,0.4)', borderRadius: '12px', color: '#00ff66', fontSize: '14px', fontWeight: '600', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>üõ∞Ô∏è HOST NEW SESSION</button>
                <div style={{ textAlign: 'center', padding: '15px 0', color: '#4a6a4a', fontSize: '11px', letterSpacing: '2px' }}>‚Äî OR ‚Äî</div>
                <div style={{ background: 'rgba(0,20,0,0.4)', border: '1px solid rgba(0,255,100,0.15)', borderRadius: '12px', padding: '20px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', marginBottom: '10px' }}>SESSION CODE</label>
                  <input type="text" value={joinCode} onChange={(e) => setJoinCode(e.target.value.toUpperCase())} placeholder="XXXXXX" maxLength={6} style={{ width: '100%', padding: '15px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '24px', letterSpacing: '8px', outline: 'none', fontFamily: 'inherit', textAlign: 'center', marginBottom: '15px' }} />
                  <button onClick={joinSession} style={{ width: '100%', padding: '15px', background: 'transparent', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#8ac88a', fontSize: '12px', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>JOIN SESSION</button>
                </div>
              </div>
            )}

            {/* Session */}
            {(sessionState === 'hosting' || sessionState === 'joined') && (
              <>
                {/* Top Bar */}
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '12px 18px', background: 'rgba(0,20,0,0.6)', border: '1px solid rgba(0,255,100,0.2)', borderRadius: '10px', marginBottom: '15px', flexWrap: 'wrap', gap: '15px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '20px', flexWrap: 'wrap' }}>
                    <div>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>SESSION</span>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '4px' }}>
                        <span style={{ fontSize: '18px', letterSpacing: '4px', color: '#00ff66', fontWeight: '600' }}>{sessionCode}</span>
                        <button onClick={copyCode} style={{ background: 'rgba(0,255,100,0.1)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '4px', color: '#00ff66', padding: '4px 8px', fontSize: '9px', cursor: 'pointer', fontFamily: 'inherit' }}>COPY</button>
                      </div>
                    </div>
                    <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />
                    <div>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>ROLE</span>
                      <div style={{ fontSize: '12px', marginTop: '4px', color: roleConfig[myRole].color, display: 'flex', alignItems: 'center', gap: '6px' }}>
                        {roleConfig[myRole].icon} {roleConfig[myRole].label}
                      </div>
                    </div>
                    {myRole === 'operator' && myChannelId && (
                      <>
                        <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />
                        <div>
                          <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>CHANNEL</span>
                          <div style={{ fontSize: '12px', marginTop: '4px', color: teams.find(t => t.id === myChannelId)?.color || '#00ff66' }}>
                            {teams.find(t => t.id === myChannelId)?.name.toUpperCase() || 'UNASSIGNED'}
                          </div>
                        </div>
                      </>
                    )}
                    <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />
                    <div>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>STATUS</span>
                      <div style={{ fontSize: '12px', marginTop: '4px', color: statusConfig[myStatus].color }}>{statusConfig[myStatus].icon} {statusConfig[myStatus].label}</div>
                    </div>
                  </div>
                  <div style={{ display: 'flex', gap: '8px' }}>
                    <button onClick={() => setGlobalMute(!globalMute)} style={{ background: globalMute ? 'rgba(255,50,50,0.2)' : 'rgba(0,255,100,0.1)', border: `1px solid ${globalMute ? 'rgba(255,50,50,0.5)' : 'rgba(0,255,100,0.3)'}`, borderRadius: '6px', color: globalMute ? '#ff6666' : '#00ff66', padding: '8px 12px', fontSize: '14px', cursor: 'pointer' }}>{globalMute ? 'üîá' : 'üîä'}</button>
                    <button onClick={leaveSession} style={{ background: 'rgba(255,50,50,0.1)', border: '1px solid rgba(255,50,50,0.3)', borderRadius: '6px', color: '#ff6666', padding: '8px 14px', fontSize: '10px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>LEAVE</button>
                  </div>
                </div>

                {/* Signals */}
                <div style={{ display: 'flex', gap: '10px', marginBottom: '15px', padding: '15px', background: 'rgba(0,20,0,0.4)', border: '1px solid rgba(255,200,0,0.2)', borderRadius: '10px', flexWrap: 'wrap' }}>
                  <span style={{ fontSize: '10px', letterSpacing: '2px', color: '#aa9944', display: 'flex', alignItems: 'center', marginRight: '10px' }}>SIGNALS</span>
                  <button onClick={() => broadcastWhistle('attention')} style={{ flex: 1, minWidth: '100px', padding: '10px 15px', background: 'rgba(255,200,0,0.1)', border: '1px solid rgba(255,200,0,0.4)', borderRadius: '6px', color: '#ffcc00', fontSize: '11px', cursor: 'pointer', fontFamily: 'inherit' }}>üìØ ATTENTION</button>
                  <button onClick={() => broadcastWhistle('alert')} style={{ flex: 1, minWidth: '100px', padding: '10px 15px', background: 'rgba(255,150,0,0.1)', border: '1px solid rgba(255,150,0,0.4)', borderRadius: '6px', color: '#ff9900', fontSize: '11px', cursor: 'pointer', fontFamily: 'inherit' }}>üîî ALERT</button>
                  <button onClick={() => broadcastWhistle('urgent')} style={{ flex: 1, minWidth: '100px', padding: '10px 15px', background: 'rgba(255,80,80,0.1)', border: '1px solid rgba(255,80,80,0.4)', borderRadius: '6px', color: '#ff6666', fontSize: '11px', cursor: 'pointer', fontFamily: 'inherit' }}>‚ö†Ô∏è URGENT</button>
                </div>

                {/* TX Meter */}
                {isSpeaking && (
                  <div style={{ marginBottom: '15px', padding: '12px 18px', background: 'rgba(0,20,0,0.6)', border: '1px solid rgba(0,255,100,0.2)', borderRadius: '8px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                      <span style={{ fontSize: '10px', letterSpacing: '2px', color: '#00ff66' }}>
                        TX ‚Üí {getSpeakingChannels().map(ch => ch === COMMAND_NET_ID ? 'CMD NET' : teams.find(t => t.id === ch)?.name || ch).join(', ')}
                      </span>
                      <div style={{ flex: 1, height: '8px', background: 'rgba(0,0,0,0.5)', borderRadius: '4px', overflow: 'hidden' }}>
                        <div style={{ width: `${audioLevel * 100}%`, height: '100%', background: audioLevel > 0.7 ? 'linear-gradient(90deg, #00ff66, #ffff00, #ff3300)' : '#00ff66', transition: 'width 0.05s' }} />
                      </div>
                      <span style={{ fontSize: '11px', fontWeight: 'bold', color: audioLevel > 0.7 ? '#ff3300' : '#00ff66', minWidth: '35px' }}>{Math.round(audioLevel * 100)}%</span>
                    </div>
                  </div>
                )}

                {/* Hotkeys */}
                <div style={{ marginBottom: '15px', padding: '10px 15px', background: 'rgba(0,0,0,0.3)', borderRadius: '6px', display: 'flex', gap: '15px', flexWrap: 'wrap', justifyContent: 'center' }}>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+M</kbd> Mute</span>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Shift+A</kbd> Ready</span>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Alt+D</kbd> Down</span>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Alt+W</kbd> Wait</span>
                </div>

                {/* Unassigned Users (Commander only) */}
                {myRole === 'commander' && getUnassignedUsers().length > 0 && (
                  <div style={{ background: 'rgba(100,50,0,0.2)', border: '1px solid rgba(255,150,0,0.3)', borderRadius: '10px', padding: '15px', marginBottom: '15px' }}>
                    <div style={{ fontSize: '10px', letterSpacing: '2px', color: '#ff9900', marginBottom: '10px' }}>‚ö†Ô∏è UNASSIGNED ‚Äî Drag to channel</div>
                    <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                      {getUnassignedUsers().map(user => (
                        <div
                          key={user.peerId}
                          draggable
                          onDragStart={(e) => handleDragStart(e, user)}
                          onDragEnd={() => setDraggedUser(null)}
                          className="user-chip"
                          style={{ display: 'flex', alignItems: 'center', gap: '8px', padding: '8px 12px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(255,150,0,0.4)', borderRadius: '6px' }}
                        >
                          <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: statusConfig[user.status || 'standby'].color }} />
                          <span style={{ fontSize: '11px' }}>{user.username.toUpperCase()}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Command Net (only visible to commander and squad leaders) */}
                {canSeeCommandNet(myRole) && (
                  <ChannelCard isCommandNet={true} channel={{}} />
                )}

                {/* Create Channel (Commander) */}
                {myRole === 'commander' && (
                  <button onClick={() => setShowCreateModal(true)} style={{ width: '100%', padding: '16px', marginBottom: '15px', background: 'transparent', border: '2px dashed rgba(0,255,100,0.3)', borderRadius: '12px', color: '#4a8a4a', fontSize: '12px', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>+ CREATE CHANNEL</button>
                )}

                {/* Squad Channels */}
                {myRole === 'commander' && teams.map(team => (
                  <ChannelCard key={team.id} channel={team} />
                ))}

                {/* Squad Leader view - their squad + command net */}
                {myRole === 'squadleader' && teams.filter(t => t.id === myChannelId).map(team => (
                  <ChannelCard key={team.id} channel={team} />
                ))}

                {/* Operator view - just their squad */}
                {myRole === 'operator' && teams.filter(t => t.id === myChannelId).map(team => (
                  <ChannelCard key={team.id} channel={team} />
                ))}

                {myRole === 'operator' && !myChannelId && (
                  <div style={{ textAlign: 'center', padding: '50px', color: '#ff9900', background: 'rgba(100,50,0,0.2)', borderRadius: '12px', border: '1px solid rgba(255,150,0,0.3)' }}>
                    <p style={{ fontSize: '14px', letterSpacing: '2px', marginBottom: '10px' }}>‚è≥ AWAITING ASSIGNMENT</p>
                    <p style={{ fontSize: '11px', color: '#aa7733' }}>Commander will assign you to a channel</p>
                  </div>
                )}
              </>
            )}
          </div>

          {/* Create Modal */}
          {showCreateModal && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }} onClick={() => setShowCreateModal(false)}>
              <div style={{ background: 'linear-gradient(135deg, #0f1f0f, #1a2a1a)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '16px', padding: '35px', width: '380px', maxWidth: '90vw' }} onClick={(e) => e.stopPropagation()}>
                <h3 style={{ margin: '0 0 25px 0', fontSize: '14px', letterSpacing: '4px', textAlign: 'center' }}>NEW CHANNEL</h3>
                <input type="text" value={newTeamName} onChange={(e) => setNewTeamName(e.target.value)} placeholder="Channel name..." autoFocus style={{ width: '100%', padding: '14px 18px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '14px', outline: 'none', fontFamily: 'inherit', marginBottom: '18px' }} onKeyDown={(e) => e.key === 'Enter' && createTeam()} />
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '2px', color: '#6a9a6a', marginBottom: '10px' }}>COLOR</label>
                  <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                    {colorOptions.map(color => (<div key={color} onClick={() => setNewTeamColor(color)} style={{ width: '28px', height: '28px', borderRadius: '6px', background: color, cursor: 'pointer', border: newTeamColor === color ? '3px solid white' : '3px solid transparent', boxShadow: newTeamColor === color ? `0 0 15px ${color}` : 'none' }} />))}
                  </div>
                </div>
                <div style={{ display: 'flex', gap: '10px' }}>
                  <button onClick={() => setShowCreateModal(false)} style={{ flex: 1, padding: '12px', background: 'transparent', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '6px', color: '#888', fontSize: '11px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>CANCEL</button>
                  <button onClick={createTeam} style={{ flex: 1, padding: '12px', background: `${newTeamColor}33`, border: `1px solid ${newTeamColor}88`, borderRadius: '6px', color: newTeamColor, fontSize: '11px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>CREATE</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<VoIPApp />);
  </script>
</body>
</html>
