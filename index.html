<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>G-COMMS | GBRS Communications System v.0.9.3</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üì°</text></svg>">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
    html, body { 
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      background: linear-gradient(135deg, #0a0f0a 0%, #1a1f1a 50%, #0f1a0f 100%);
      min-height: 100vh;
      min-height: -webkit-fill-available;
      color: #e0ffe0;
      overflow-x: hidden;
      touch-action: manipulation;
    }
    ::placeholder { color: #4a6a4a; }
    input, button { font-size: 16px !important; } /* Prevent iOS zoom */
    button { 
      cursor: pointer; 
      -webkit-touch-callout: none;
      touch-action: manipulation;
    }
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 24px;
      background: transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 4px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #e0ffe0;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0,255,100,0.5);
      margin-top: -8px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #e0ffe0;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(0,255,100,0.5);
    }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } }
    @keyframes glow { 0%, 100% { box-shadow: 0 0 20px rgba(0,255,100,0.2); } 50% { box-shadow: 0 0 30px rgba(0,255,100,0.4); } }
    @keyframes flashAlert { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes soundWave { 0%, 100% { height: 4px; } 50% { height: 16px; } }
    .user-chip { cursor: grab; user-select: none; transition: all 0.2s; }
    .user-chip:active { cursor: grabbing; }
    .channel-drop-zone { transition: all 0.2s; }
    .channel-drop-zone.drag-over { background: rgba(0,255,100,0.1); border-color: rgba(0,255,100,0.5) !important; }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      .desktop-only { display: none !important; }
    }
    @media (min-width: 769px) {
      .mobile-only { display: none !important; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback, useMemo } = React;

    const COMMAND_NET_ID = 'command-net';
    
    // Detect mobile
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;

    const VoIPApp = () => {
      const [sessionState, setSessionState] = useState('lobby');
      const [sessionCode, setSessionCode] = useState('');
      const [joinCode, setJoinCode] = useState('');
      const [username, setUsername] = useState('');
      const [error, setError] = useState('');
      const [connectedUsers, setConnectedUsers] = useState([]);
      const [myStatus, setMyStatus] = useState('standby');
      const [myChannelId, setMyChannelId] = useState(null);
      const [myRole, setMyRole] = useState('operator'); // operator, squadleader, commander
      
      const [teams, setTeams] = useState([
        { id: 1, name: 'Alpha Squad', volume: 80, color: '#00ff66' },
        { id: 2, name: 'Bravo Unit', volume: 80, color: '#ffcc00' },
      ]);
      const [newTeamName, setNewTeamName] = useState('');
      const [newTeamColor, setNewTeamColor] = useState('#00ff66');
      const [showCreateModal, setShowCreateModal] = useState(false);
      
      // Channel audio states - keyed by channel ID
      const [channelStates, setChannelStates] = useState({});
      // { channelId: { listen: bool, speak: bool }, ... }
      
      const [audioLevel, setAudioLevel] = useState(0);
      const [globalMute, setGlobalMute] = useState(false);
      const [whistleActive, setWhistleActive] = useState(false);
      const [incomingWhistle, setIncomingWhistle] = useState(null);
      const [draggedUser, setDraggedUser] = useState(null);
      const [commandNetVolume, setCommandNetVolume] = useState(80);
      const [allCallActive, setAllCallActive] = useState(false);
      const [selectedUserForAssign, setSelectedUserForAssign] = useState(null); // Mobile: tap user then tap channel
      
      const peerRef = useRef(null);
      const connectionsRef = useRef(new Map());
      const localStreamRef = useRef(null);
      const audioContextRef = useRef(null);
      const analyserRef = useRef(null);
      const animationRef = useRef(null);
      const isHostRef = useRef(false);
      const audioElementsRef = useRef(new Map()); // peerId -> Audio element
      const teamsRef = useRef(teams);
      const myStatusRef = useRef(myStatus);
      const myChannelIdRef = useRef(myChannelId);
      const myRoleRef = useRef(myRole);
      const connectedUsersRef = useRef(connectedUsers);
      const channelStatesRef = useRef(channelStates);
      const allCallActiveRef = useRef(allCallActive);

      useEffect(() => { teamsRef.current = teams; }, [teams]);
      useEffect(() => { myStatusRef.current = myStatus; }, [myStatus]);
      useEffect(() => { myChannelIdRef.current = myChannelId; }, [myChannelId]);
      useEffect(() => { myRoleRef.current = myRole; }, [myRole]);
      useEffect(() => { connectedUsersRef.current = connectedUsers; }, [connectedUsers]);
      useEffect(() => { channelStatesRef.current = channelStates; }, [channelStates]);
      useEffect(() => { allCallActiveRef.current = allCallActive; }, [allCallActive]);

      // Check if currently speaking on any channel
      const isSpeaking = useMemo(() => {
        if (globalMute) return false;
        if (allCallActive && myRole === 'commander') return true;
        if (!channelStates || Object.keys(channelStates).length === 0) return false;
        return Object.values(channelStates).some(s => s && s.speak === true);
      }, [globalMute, allCallActive, myRole, channelStates]);
      
      // Get channels I'm speaking to
      const getSpeakingChannels = useCallback(() => {
        if (globalMute) return [];
        
        // If ALL-CALL is active (commander only), return all squad channels
        if (allCallActive && myRoleRef.current === 'commander') {
          return teamsRef.current.map(t => t.id);
        }
        
        if (!channelStates || Object.keys(channelStates).length === 0) {
          return [];
        }
        
        const channels = [];
        Object.entries(channelStates).forEach(([id, state]) => {
          if (state && state.speak) {
            channels.push(id === COMMAND_NET_ID ? COMMAND_NET_ID : parseInt(id));
          }
        });
        return channels;
      }, [channelStates, globalMute, allCallActive]);

      const colorOptions = [
        '#00ff66', '#ffcc00', '#ff6b6b', '#4ecdc4', '#a855f7', 
        '#3b82f6', '#f97316', '#ec4899', '#84cc16', '#06b6d4'
      ];

      const statusConfig = {
        standby: { color: '#666666', label: 'STANDBY', icon: '‚ö´' },
        ready: { color: '#00ff66', label: 'READY', icon: 'üü¢' },
        dead: { color: '#ff4444', label: 'DOWN', icon: 'üî¥' },
        wait: { color: '#ffaa00', label: 'WAIT ONE', icon: 'üü°' }
      };

      const roleConfig = {
        operator: { label: 'OPERATOR', color: '#00ff66', icon: '‚óè' },
        squadleader: { label: 'SQUAD LEADER', color: '#4ecdc4', icon: '‚óÜ' },
        commander: { label: 'COMMANDER', color: '#ffcc00', icon: '‚òÖ' }
      };

      // Check if user can see command net
      const canSeeCommandNet = (role) => role === 'commander' || role === 'squadleader';

      // Get channels visible to current user
      const getVisibleChannels = () => {
        if (myRole === 'commander') {
          return teams; // Commander sees all squad channels
        } else if (myRole === 'squadleader') {
          return teams.filter(t => t.id === myChannelId); // Squad leader sees their squad
        } else {
          return teams.filter(t => t.id === myChannelId); // Operator sees their squad
        }
      };

      // Update audio routing - determines who we hear
      const updateAudioRouting = useCallback(() => {
        console.log('Updating audio routing, users:', connectedUsersRef.current.length);
        
        connectedUsersRef.current.forEach(user => {
          if (user.peerId === peerRef.current?.id) return;
          
          const audioEl = audioElementsRef.current.get(user.peerId);
          if (!audioEl) {
            console.log('No audio element for', user.username);
            return;
          }
          
          let shouldHear = false;
          let volume = 0.8;
          
          // Check if we should hear this user based on their speaking channels and our listening channels
          if (user.speaking && user.speakingChannels && user.speakingChannels.length > 0) {
            console.log(user.username, 'is speaking on channels:', user.speakingChannels);
            console.log('My channel states:', channelStatesRef.current);
            
            for (const speakingCh of user.speakingChannels) {
              // Check both string and number versions of channel ID
              const chState = channelStatesRef.current[speakingCh] || channelStatesRef.current[String(speakingCh)];
              console.log('Checking channel', speakingCh, 'state:', chState);
              
              if (chState?.listen) {
                shouldHear = true;
                // Get volume for this channel
                if (speakingCh === COMMAND_NET_ID) {
                  volume = commandNetVolume / 100;
                } else {
                  const team = teamsRef.current.find(t => t.id === speakingCh || t.id === parseInt(speakingCh));
                  if (team) volume = team.volume / 100;
                }
                break;
              }
            }
          }
          
          if (globalMute) shouldHear = false;
          
          console.log('Should hear', user.username, ':', shouldHear, 'volume:', volume);
          audioEl.muted = !shouldHear;
          audioEl.volume = volume;
        });
      }, [globalMute, commandNetVolume]);

      useEffect(() => {
        updateAudioRouting();
      }, [connectedUsers, channelStates, globalMute, teams, updateAudioRouting]);

      const broadcastStatus = useCallback((newStatus) => {
        setMyStatus(newStatus);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'status-update', peerId: peerRef.current?.id, status: newStatus });
          }
        });
      }, []);

      const broadcastSpeakingState = useCallback((speakingChannels) => {
        console.log('Broadcasting speaking state, channels:', speakingChannels);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ 
              type: 'speaking-update', 
              peerId: peerRef.current?.id, 
              speaking: speakingChannels.length > 0,
              speakingChannels: speakingChannels
            });
          }
        });
      }, []);

      useEffect(() => {
        if (sessionState !== 'lobby') {
          const channels = getSpeakingChannels();
          broadcastSpeakingState(channels);
        }
      }, [channelStates, sessionState, globalMute, allCallActive, getSpeakingChannels, broadcastSpeakingState]);

      // Toggle channel listen/speak
      const toggleChannelListen = (channelId) => {
        setChannelStates(prev => ({
          ...prev,
          [channelId]: { ...prev[channelId], listen: !prev[channelId]?.listen }
        }));
      };

      const toggleChannelSpeak = (channelId) => {
        setChannelStates(prev => ({
          ...prev,
          [channelId]: { ...prev[channelId], speak: !prev[channelId]?.speak }
        }));
      };

      // Promote user to squad leader (host only)
      const promoteToSquadLeader = useCallback((userId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, role: 'squadleader' } : u
        ));
        
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'role-update', peerId: userId, role: 'squadleader' });
          }
        });
      }, []);

      // Demote squad leader to operator (host only)
      const demoteToOperator = useCallback((userId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, role: 'operator' } : u
        ));
        
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'role-update', peerId: userId, role: 'operator' });
          }
        });
      }, []);

      // Move user to channel (host only)
      const moveUserToChannel = useCallback((userId, channelId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, channelId } : u
        ));
        
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'user-moved', peerId: userId, channelId });
          }
        });
        
        if (userId === peerRef.current?.id) {
          setMyChannelId(channelId);
        }
      }, []);

      const playWhistle = useCallback((type = 'attention') => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        if (type === 'attention') {
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(800, ctx.currentTime);
          oscillator.frequency.linearRampToValueAtTime(1600, ctx.currentTime + 0.3);
          oscillator.frequency.linearRampToValueAtTime(1200, ctx.currentTime + 0.6);
          gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
          gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.7);
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.7);
        } else if (type === 'alert') {
          oscillator.type = 'square';
          oscillator.frequency.setValueAtTime(1000, ctx.currentTime);
          gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
          gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.1);
          gainNode.gain.setValueAtTime(0.2, ctx.currentTime + 0.15);
          gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.25);
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.3);
        } else if (type === 'urgent') {
          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(1200, ctx.currentTime);
          gainNode.gain.setValueAtTime(0.15, ctx.currentTime);
          for (let i = 0; i < 3; i++) {
            const t = ctx.currentTime + i * 0.15;
            gainNode.gain.setValueAtTime(0.15, t);
            gainNode.gain.setValueAtTime(0, t + 0.1);
          }
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.5);
        }
      }, []);

      const broadcastWhistle = useCallback((type) => {
        playWhistle(type);
        setWhistleActive(true);
        setTimeout(() => setWhistleActive(false), 800);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) connData.conn.send({ type: 'whistle', whistleType: type, from: username });
        });
      }, [playWhistle, username]);

      // Hotkeys
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (sessionState === 'lobby') return;
          if (e.target.tagName === 'INPUT') return;
          
          if (e.ctrlKey && e.shiftKey && (e.key === 'A' || e.key === 'a')) {
            e.preventDefault(); broadcastStatus('ready'); return;
          }
          if (e.ctrlKey && e.altKey && (e.key === 'd' || e.key === 'D')) {
            e.preventDefault(); broadcastStatus('dead'); return;
          }
          if (e.ctrlKey && e.altKey && (e.key === 'w' || e.key === 'W')) {
            e.preventDefault(); broadcastStatus('wait'); return;
          }
          if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'm') {
            e.preventDefault(); setGlobalMute(prev => !prev); return;
          }
          if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'w') {
            e.preventDefault(); broadcastWhistle('attention'); return;
          }
          // Ctrl+0 - Toggle ALL-CALL (commander only)
          if (e.ctrlKey && e.key === '0' && myRoleRef.current === 'commander') {
            e.preventDefault();
            setAllCallActive(prev => !prev);
            return;
          }
          // Ctrl+` - Toggle Command Net listen (if visible)
          if (e.ctrlKey && e.key === '`' && canSeeCommandNet(myRoleRef.current)) {
            e.preventDefault();
            toggleChannelListen(COMMAND_NET_ID);
            return;
          }
          // Ctrl+Shift+0 - Toggle Command Net speak (if visible)
          if (e.ctrlKey && e.shiftKey && e.key === ')' && canSeeCommandNet(myRoleRef.current)) {
            e.preventDefault();
            toggleChannelSpeak(COMMAND_NET_ID);
            return;
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [sessionState, broadcastWhistle, broadcastStatus]);

      const generateCode = () => {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
        return code;
      };

      const initPeer = useCallback((peerId) => {
        return new Promise((resolve, reject) => {
          const peer = new Peer(peerId, { debug: 1 });
          peer.on('open', (id) => { console.log('Connected:', id); resolve(peer); });
          peer.on('error', (err) => {
            if (err.type === 'unavailable-id') reject(new Error('Session code already in use'));
            else if (err.type === 'peer-unavailable') reject(new Error('Session not found'));
            else reject(err);
          });
          peerRef.current = peer;
        });
      }, []);

      const getLocalStream = useCallback(async () => {
        if (!localStreamRef.current) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
              audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } 
            });
            localStreamRef.current = stream;
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
            analyserRef.current = audioContextRef.current.createAnalyser();
            const source = audioContextRef.current.createMediaStreamSource(stream);
            source.connect(analyserRef.current);
            analyserRef.current.fftSize = 256;
            return stream;
          } catch (err) {
            setError('Microphone access required');
            return null;
          }
        }
        return localStreamRef.current;
      }, []);

      useEffect(() => {
        let animFrame;
        if (isSpeaking && analyserRef.current) {
          const updateLevel = () => {
            const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
            analyserRef.current.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
            setAudioLevel(avg / 255);
            animFrame = requestAnimationFrame(updateLevel);
          };
          updateLevel();
        } else {
          setAudioLevel(0);
        }
        return () => { 
          if (animFrame) cancelAnimationFrame(animFrame);
        };
      }, [isSpeaking]);

      useEffect(() => {
        console.log('isSpeaking changed:', isSpeaking, 'channelStates:', channelStates, 'globalMute:', globalMute, 'allCallActive:', allCallActive);
        if (localStreamRef.current) {
          const tracks = localStreamRef.current.getAudioTracks();
          console.log('Audio tracks:', tracks.length);
          tracks.forEach(track => { 
            track.enabled = isSpeaking;
            console.log('Mic track enabled:', track.enabled);
          });
        } else {
          console.log('No localStreamRef.current');
        }
      }, [isSpeaking, channelStates, globalMute, allCallActive]);

      const handleData = useCallback((data, fromPeerId) => {
        console.log('Received:', data.type, 'from:', fromPeerId);
        
        if (data.type === 'whistle') {
          playWhistle(data.whistleType);
          setIncomingWhistle({ type: data.whistleType, from: data.from });
          setTimeout(() => setIncomingWhistle(null), 2000);
        } else if (data.type === 'status-update') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, status: data.status } : u));
        } else if (data.type === 'speaking-update') {
          console.log('Received speaking update:', data.peerId, 'speaking:', data.speaking, 'channels:', data.speakingChannels);
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { 
            ...u, 
            speaking: data.speaking,
            speakingChannels: data.speakingChannels || []
          } : u));
        } else if (data.type === 'role-update') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, role: data.role } : u));
          if (data.peerId === peerRef.current?.id) {
            setMyRole(data.role);
            // If promoted to squad leader, enable command net listening by default
            if (data.role === 'squadleader') {
              setChannelStates(prev => ({
                ...prev,
                [COMMAND_NET_ID]: { listen: true, speak: false }
              }));
            }
          }
        } else if (data.type === 'user-moved') {
          console.log('User moved:', data.peerId, 'to channel:', data.channelId);
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, channelId: data.channelId } : u));
          if (data.peerId === peerRef.current?.id) {
            console.log('I was moved to channel:', data.channelId);
            setMyChannelId(data.channelId);
            // Enable listen/speak on assigned channel
            setChannelStates(prev => {
              const newState = {
                ...prev,
                [data.channelId]: { listen: true, speak: true }
              };
              console.log('New channelStates:', newState);
              return newState;
            });
          }
        } else if (data.type === 'user-joined') {
          // Create the new user object (always unassigned when joining)
          const newUser = { 
            peerId: data.peerId, 
            username: data.username, 
            status: data.status || 'standby', 
            speaking: false,
            speakingChannels: [],
            channelId: null,  // Always start unassigned
            role: 'operator',
            isHost: data.isHost || false
          };
          
          // Add to connected users if not already present
          setConnectedUsers(prev => {
            if (!prev.find(u => u.peerId === data.peerId)) {
              return [...prev, newUser];
            }
            return prev;
          });
          
          // Host-specific: send sync state to new user and notify others
          if (isHostRef.current) {
            const conn = connectionsRef.current.get(fromPeerId)?.conn;
            if (conn?.open) {
              // Build users list including the new user
              const currentUsers = connectedUsersRef.current.filter(u => u.peerId !== data.peerId);
              const allUsers = [...currentUsers, newUser];
              
              conn.send({
                type: 'sync-state',
                teams: teamsRef.current,
                users: allUsers,
                yourChannelId: null,
                yourRole: 'operator'
              });
            }
            
            // Notify other connected users
            connectionsRef.current.forEach((connData, peerId) => {
              if (peerId !== fromPeerId && connData.conn?.open) {
                connData.conn.send({ 
                  type: 'user-joined', 
                  ...newUser
                });
              }
            });
          }
        } else if (data.type === 'sync-state') {
          setTeams(data.teams);
          // Ensure all users have required fields
          const usersWithDefaults = data.users.map(u => ({
            ...u,
            speaking: u.speaking || false,
            speakingChannels: u.speakingChannels || [],
            status: u.status || 'standby',
            role: u.role || 'operator'
          }));
          setConnectedUsers(usersWithDefaults);
          setMyChannelId(data.yourChannelId);
          setMyRole(data.yourRole || 'operator');
          // Set up initial channel states only if assigned to a channel
          if (data.yourChannelId !== null && data.yourChannelId !== undefined) {
            setChannelStates(prev => ({
              ...prev,
              [data.yourChannelId]: { listen: true, speak: true }
            }));
          }
        } else if (data.type === 'teams-update') {
          setTeams(data.teams);
        } else if (data.type === 'user-left') {
          setConnectedUsers(prev => prev.filter(u => u.peerId !== data.peerId));
        }
      }, [playWhistle]);

      const setupConnection = useCallback((conn) => {
        conn.on('open', async () => {
          console.log('Connection opened:', conn.peer);
          connectionsRef.current.set(conn.peer, { ...connectionsRef.current.get(conn.peer), conn });
          conn.send({ 
            type: 'user-joined', 
            peerId: peerRef.current.id, 
            username: username, 
            status: myStatusRef.current,
            channelId: myChannelIdRef.current,
            role: myRoleRef.current,
            isHost: isHostRef.current
          });
          const stream = await getLocalStream();
          if (stream && peerRef.current) {
            const call = peerRef.current.call(conn.peer, stream);
            setupCall(call);
          }
        });
        conn.on('data', (data) => handleData(data, conn.peer));
        conn.on('close', () => {
          console.log('Connection closed:', conn.peer);
          const audioEl = audioElementsRef.current.get(conn.peer);
          if (audioEl) {
            audioEl.srcObject = null;
            audioEl.remove();
            audioElementsRef.current.delete(conn.peer);
          }
          connectionsRef.current.delete(conn.peer);
          setConnectedUsers(prev => prev.filter(u => u.peerId !== conn.peer));
        });
      }, [username, getLocalStream, handleData]);

      const setupCall = useCallback((call) => {
        call.on('stream', (remoteStream) => {
          console.log('Got audio stream from:', call.peer);
          
          // Create or get audio element for this peer
          let audioEl = audioElementsRef.current.get(call.peer);
          if (!audioEl) {
            audioEl = new Audio();
            audioEl.autoplay = true;
            audioEl.muted = true; // Start muted, updateAudioRouting will unmute if needed
            audioElementsRef.current.set(call.peer, audioEl);
          }
          
          audioEl.srcObject = remoteStream;
          audioEl.play().catch(e => console.log('Audio play error:', e));
          
          connectionsRef.current.set(call.peer, { ...connectionsRef.current.get(call.peer), stream: remoteStream });
          
          // Trigger routing update after a short delay
          setTimeout(() => updateAudioRouting(), 100);
        });
        
        call.on('error', (err) => {
          console.error('Call error:', err);
        });
      }, [updateAudioRouting]);

      const hostSession = async () => {
        if (!username.trim()) { setError('Please enter your callsign'); return; }
        setError('');
        const code = generateCode();
        try {
          // Get mic access first
          const stream = await getLocalStream();
          if (!stream) {
            setError('Microphone access required');
            return;
          }
          console.log('Got local stream for host');
          
          const peer = await initPeer(`gcomms-${code}-host`);
          peer.on('connection', (conn) => { console.log('Incoming:', conn.peer); setupConnection(conn); });
          peer.on('call', async (call) => {
            const stream = await getLocalStream();
            if (stream) { call.answer(stream); setupCall(call); }
          });
          isHostRef.current = true;
          setSessionCode(code);
          setSessionState('hosting');
          setMyRole('commander');
          // Commander starts with command net and all channels listen enabled
          const initialStates = { [COMMAND_NET_ID]: { listen: true, speak: false } };
          teams.forEach(t => { initialStates[t.id] = { listen: true, speak: false }; });
          setChannelStates(initialStates);
          setConnectedUsers([{ 
            peerId: peer.id, 
            username: username, 
            isHost: true, 
            status: 'standby', 
            speaking: false,
            speakingChannels: [],
            channelId: null,
            role: 'commander'
          }]);
        } catch (err) { setError(err.message); }
      };

      const joinSession = async () => {
        if (!username.trim()) { setError('Please enter your callsign'); return; }
        if (!joinCode.trim()) { setError('Please enter a session code'); return; }
        setError('');
        const code = joinCode.toUpperCase().replace(/[^A-Z0-9]/g, '');
        const uniqueId = `gcomms-${code}-${Date.now()}`;
        try {
          // Get mic access first
          const stream = await getLocalStream();
          if (!stream) {
            setError('Microphone access required');
            return;
          }
          console.log('Got local stream for joiner');
          
          const peer = await initPeer(uniqueId);
          peer.on('connection', (conn) => setupConnection(conn));
          peer.on('call', async (call) => {
            const stream = await getLocalStream();
            if (stream) { call.answer(stream); setupCall(call); }
          });
          const hostPeerId = `gcomms-${code}-host`;
          const conn = peer.connect(hostPeerId, { reliable: true });
          conn.on('error', () => setError('Failed to connect'));
          setupConnection(conn);
          isHostRef.current = false;
          setSessionCode(code);
          setSessionState('joined');
          setMyRole('operator');
          setConnectedUsers([{ peerId: peer.id, username: username, status: 'standby', speaking: false, speakingChannels: [], channelId: null, role: 'operator' }]);
        } catch (err) { setError(err.message); }
      };

      const leaveSession = () => {
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'user-left', peerId: peerRef.current?.id });
            connData.conn.close();
          }
        });
        connectionsRef.current.clear();
        // Clean up audio elements
        audioElementsRef.current.forEach(audioEl => {
          audioEl.srcObject = null;
          audioEl.remove();
        });
        audioElementsRef.current.clear();
        if (localStreamRef.current) { localStreamRef.current.getTracks().forEach(track => track.stop()); localStreamRef.current = null; }
        if (peerRef.current) { peerRef.current.destroy(); peerRef.current = null; }
        setSessionState('lobby');
        setSessionCode('');
        setConnectedUsers([]);
        setMyChannelId(null);
        setMyRole('operator');
        setMyStatus('standby');
        setChannelStates({});
        setAllCallActive(false);
        isHostRef.current = false;
      };

      const syncTeams = (newTeams) => {
        if (isHostRef.current) {
          connectionsRef.current.forEach((connData) => {
            if (connData.conn?.open) connData.conn.send({ type: 'teams-update', teams: newTeams });
          });
        }
      };

      const createTeam = () => {
        if (newTeamName.trim()) {
          const newTeam = { id: Date.now(), name: newTeamName.trim(), volume: 80, color: newTeamColor };
          const newTeams = [...teams, newTeam];
          setTeams(newTeams);
          setChannelStates(prev => ({ ...prev, [newTeam.id]: { listen: true, speak: false } }));
          setNewTeamName('');
          setNewTeamColor('#00ff66');
          setShowCreateModal(false);
          syncTeams(newTeams);
        }
      };

      const deleteTeam = (id) => {
        setConnectedUsers(prev => prev.map(u => u.channelId === id ? { ...u, channelId: null } : u));
        const newTeams = teams.filter(t => t.id !== id);
        setTeams(newTeams);
        setChannelStates(prev => { const n = { ...prev }; delete n[id]; return n; });
        syncTeams(newTeams);
      };

      const copyCode = () => navigator.clipboard.writeText(sessionCode);

      useEffect(() => {
        const speakingChannels = getSpeakingChannels();
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === peerRef.current?.id 
            ? { ...u, status: myStatus, speaking: isSpeaking, speakingChannels: speakingChannels } 
            : u
        ));
      }, [myStatus, isSpeaking, allCallActive, getSpeakingChannels]);

      // Drag and drop
      const handleDragStart = (e, user) => { if (isHostRef.current) setDraggedUser(user); };
      const handleDragOver = (e) => { if (isHostRef.current && draggedUser) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; } };
      const handleDragEnter = (e) => { if (isHostRef.current && draggedUser) e.currentTarget.classList.add('drag-over'); };
      const handleDragLeave = (e) => { e.currentTarget.classList.remove('drag-over'); };
      const handleDrop = (e, channelId) => {
        e.preventDefault();
        e.currentTarget.classList.remove('drag-over');
        if (isHostRef.current && draggedUser && !draggedUser.isHost) {
          moveUserToChannel(draggedUser.peerId, channelId);
        }
        setDraggedUser(null);
      };

      const getUsersInChannel = (channelId) => connectedUsers.filter(u => u.channelId === channelId && !u.isHost);
      const getUnassignedUsers = () => connectedUsers.filter(u => u.channelId === null && !u.isHost);
      const getCommandNetUsers = () => connectedUsers.filter(u => u.role === 'commander' || u.role === 'squadleader');

      // Channel card component
      const ChannelCard = ({ channel, isCommandNet = false }) => {
        const channelId = isCommandNet ? COMMAND_NET_ID : channel.id;
        const channelState = channelStates[channelId] || { listen: false, speak: false };
        const channelUsers = isCommandNet ? getCommandNetUsers() : getUsersInChannel(channel.id);
        const channelColor = isCommandNet ? '#ff6b6b' : channel.color;
        const channelName = isCommandNet ? 'COMMAND NET' : channel.name;
        
        const handleChannelTap = () => {
          if (isMobile && selectedUserForAssign && !isCommandNet && myRole === 'commander') {
            moveUserToChannel(selectedUserForAssign.peerId, channel.id);
            setSelectedUserForAssign(null);
          }
        };
        
        return (
          <div
            className={!isCommandNet && !isMobile ? "channel-drop-zone" : ""}
            onDragOver={!isCommandNet && !isMobile ? handleDragOver : undefined}
            onDragEnter={!isCommandNet && !isMobile ? handleDragEnter : undefined}
            onDragLeave={!isCommandNet && !isMobile ? handleDragLeave : undefined}
            onDrop={!isCommandNet && !isMobile ? (e) => handleDrop(e, channel.id) : undefined}
            onClick={handleChannelTap}
            style={{ 
              background: isCommandNet 
                ? 'linear-gradient(135deg, rgba(40,15,15,0.9), rgba(50,20,20,0.9))' 
                : 'linear-gradient(135deg, rgba(10,30,10,0.9), rgba(20,40,20,0.9))', 
              border: `2px solid ${selectedUserForAssign && !isCommandNet ? '#00ff66' : channelState.speak ? channelColor : channelState.listen ? `${channelColor}66` : 'rgba(255,255,255,0.15)'}`,
              borderRadius: '12px', 
              padding: isMobile ? '14px' : '18px',
              boxShadow: channelState.speak ? `0 0 30px ${channelColor}33` : 'none',
              marginBottom: '15px'
            }}
          >
            {isMobile && selectedUserForAssign && !isCommandNet && myRole === 'commander' && (
              <div style={{ background: 'rgba(0,255,100,0.2)', padding: '10px', borderRadius: '6px', marginBottom: '12px', textAlign: 'center', fontSize: '11px', color: '#00ff66' }}>
                TAP TO ASSIGN {selectedUserForAssign.username.toUpperCase()}
              </div>
            )}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px', flexWrap: isMobile ? 'wrap' : 'nowrap', gap: '10px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                <div style={{ width: '16px', height: '16px', borderRadius: '50%', background: channelColor, boxShadow: `0 0 10px ${channelColor}66` }} />
                <div>
                  <h2 style={{ margin: 0, fontSize: isMobile ? '14px' : '15px', fontWeight: '500', letterSpacing: '2px', color: channelColor }}>
                    {isCommandNet ? 'üì° ' : ''}{channelName.toUpperCase()}
                  </h2>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}>
                    {isCommandNet ? 'LEADERSHIP ONLY' : `${channelUsers.length} OPERATORS`}
                  </span>
                </div>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '8px', width: isMobile ? '100%' : 'auto', justifyContent: isMobile ? 'stretch' : 'flex-end' }}>
                <button
                  onClick={(e) => { e.stopPropagation(); toggleChannelListen(channelId); }}
                  style={{ flex: isMobile ? 1 : 'none', padding: isMobile ? '14px 12px' : '8px 12px', background: channelState.listen ? `${channelColor}33` : 'rgba(0,0,0,0.3)', border: `1px solid ${channelState.listen ? channelColor : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: channelState.listen ? channelColor : '#666', fontSize: isMobile ? '13px' : '11px', cursor: 'pointer', fontFamily: 'inherit' }}
                >
                  üéß {channelState.listen ? 'ON' : 'OFF'}
                </button>
                <button
                  onClick={(e) => { e.stopPropagation(); toggleChannelSpeak(channelId); }}
                  style={{ flex: isMobile ? 1 : 'none', padding: isMobile ? '14px 12px' : '8px 12px', background: channelState.speak ? `${channelColor}33` : 'rgba(0,0,0,0.3)', border: `1px solid ${channelState.speak ? channelColor : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: channelState.speak ? channelColor : '#666', fontSize: isMobile ? '13px' : '11px', cursor: 'pointer', fontFamily: 'inherit', animation: channelState.speak ? 'pulse 1s infinite' : 'none' }}
                >
                  üéôÔ∏è {channelState.speak ? 'TX' : 'OFF'}
                </button>
                {!isCommandNet && isHostRef.current && !isMobile && (
                  <button onClick={(e) => { e.stopPropagation(); deleteTeam(channel.id); }} style={{ background: 'transparent', border: 'none', color: '#5a3a3a', fontSize: '18px', cursor: 'pointer', padding: '2px 8px' }}>√ó</button>
                )}
              </div>
            </div>

            <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '15px', padding: isMobile ? '14px 12px' : '10px 12px', background: 'rgba(0,0,0,0.3)', borderRadius: '6px' }}>
              <span style={{ fontSize: '9px', color: '#6a8a6a' }}>VOL</span>
              <input 
                type="range" 
                min="0" 
                max="100" 
                value={isCommandNet ? commandNetVolume : channel.volume} 
                onClick={(e) => e.stopPropagation()}
                onChange={(e) => {
                  if (isCommandNet) {
                    setCommandNetVolume(parseInt(e.target.value));
                  } else {
                    setTeams(prev => prev.map(t => t.id === channel.id ? { ...t, volume: parseInt(e.target.value) } : t));
                  }
                }} 
                style={{ flex: 1, height: '24px', appearance: 'none', WebkitAppearance: 'none', background: `linear-gradient(to right, ${channelColor} ${isCommandNet ? commandNetVolume : channel.volume}%, rgba(100,100,100,0.3) ${isCommandNet ? commandNetVolume : channel.volume}%)`, borderRadius: '4px', cursor: 'pointer' }} 
              />
              <span style={{ fontSize: '11px', color: channelColor, minWidth: '35px', textAlign: 'right' }}>{isCommandNet ? commandNetVolume : channel.volume}%</span>
            </div>

            <div style={{ minHeight: '40px', padding: '10px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px', border: '1px dashed rgba(255,255,255,0.1)' }}>
              {channelUsers.length === 0 ? (
                <div style={{ textAlign: 'center', color: '#4a6a4a', fontSize: '11px', padding: '5px' }}>
                  {isCommandNet ? 'No leadership online' : (isHostRef.current ? (isMobile ? 'Tap to assign users' : 'Drag operators here') : 'No operators')}
                </div>
              ) : (
                <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                  {channelUsers.map(user => {
                    const status = statusConfig[user.status || 'standby'];
                    const role = roleConfig[user.role || 'operator'];
                    const isSpeakingHere = user.speaking && user.speakingChannels?.includes(channelId);
                    return (
                      <div
                        key={user.peerId}
                        draggable={isHostRef.current && !user.isHost && !isCommandNet && !isMobile}
                        onDragStart={(e) => !isMobile && handleDragStart(e, user)}
                        onDragEnd={() => setDraggedUser(null)}
                        onClick={(e) => {
                          e.stopPropagation();
                          if (isMobile && isHostRef.current && !user.isHost && !isCommandNet) {
                            setSelectedUserForAssign(selectedUserForAssign?.peerId === user.peerId ? null : user);
                          }
                        }}
                        className={isHostRef.current && !user.isHost && !isCommandNet && !isMobile ? 'user-chip' : ''}
                        style={{ 
                          display: 'flex', 
                          alignItems: 'center', 
                          gap: '8px', 
                          padding: isMobile ? '12px 14px' : '8px 12px', 
                          background: isSpeakingHere ? 'rgba(0,255,100,0.2)' : (selectedUserForAssign?.peerId === user.peerId ? 'rgba(0,255,100,0.15)' : 'rgba(0,0,0,0.4)'), 
                          border: `1px solid ${isSpeakingHere ? 'rgba(0,255,100,0.5)' : (selectedUserForAssign?.peerId === user.peerId ? '#00ff66' : 'rgba(255,255,255,0.1)')}`, 
                          borderRadius: '6px'
                        }}
                      >
                        <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: status.color, boxShadow: `0 0 6px ${status.color}`, animation: isSpeakingHere ? 'pulse 0.5s infinite' : 'none' }} />
                        <div>
                          <div style={{ fontSize: isMobile ? '12px' : '11px', color: user.peerId === peerRef.current?.id ? '#00ff66' : '#e0ffe0', display: 'flex', alignItems: 'center', gap: '4px' }}>
                            <span style={{ color: role.color }}>{role.icon}</span>
                            {user.username.toUpperCase()}
                            {user.peerId === peerRef.current?.id && <span style={{ fontSize: '9px', color: '#5a8a5a' }}>(YOU)</span>}
                          </div>
                          {isHostRef.current && !user.isHost && !isCommandNet && !isMobile && (
                            <div style={{ fontSize: '8px', marginTop: '2px' }}>
                              {user.role === 'squadleader' ? (
                                <span onClick={(e) => { e.stopPropagation(); demoteToOperator(user.peerId); }} style={{ color: '#ff6666', cursor: 'pointer' }}>DEMOTE</span>
                              ) : (
                                <span onClick={(e) => { e.stopPropagation(); promoteToSquadLeader(user.peerId); }} style={{ color: '#4ecdc4', cursor: 'pointer' }}>‚Üí SL</span>
                              )}
                            </div>
                          )}
                        </div>
                        {isSpeakingHere && (
                          <div style={{ display: 'flex', gap: '2px', alignItems: 'flex-end', height: '12px' }}>
                            {[1,2,3].map(i => (<div key={i} style={{ width: '2px', background: '#00ff66', borderRadius: '1px', animation: 'soundWave 0.5s infinite', animationDelay: `${i*0.1}s` }} />))}
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
            
            {isMobile && isHostRef.current && !isCommandNet && channelUsers.filter(u => !u.isHost).length > 0 && (
              <div style={{ marginTop: '12px', padding: '10px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px' }}>
                <div style={{ fontSize: '9px', color: '#5a7a5a', marginBottom: '8px', textAlign: 'center' }}>PROMOTE/DEMOTE</div>
                <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap', justifyContent: 'center' }}>
                  {channelUsers.filter(u => !u.isHost).map(user => (
                    <button
                      key={user.peerId}
                      onClick={(e) => {
                        e.stopPropagation();
                        user.role === 'squadleader' ? demoteToOperator(user.peerId) : promoteToSquadLeader(user.peerId);
                      }}
                      style={{
                        padding: '10px 14px',
                        background: user.role === 'squadleader' ? 'rgba(78,205,196,0.2)' : 'rgba(0,0,0,0.3)',
                        border: `1px solid ${user.role === 'squadleader' ? '#4ecdc4' : 'rgba(100,100,100,0.3)'}`,
                        borderRadius: '4px',
                        color: user.role === 'squadleader' ? '#4ecdc4' : '#888',
                        fontSize: '11px',
                        fontFamily: 'inherit'
                      }}
                    >
                      {user.username.slice(0, 8).toUpperCase()} {user.role === 'squadleader' ? '‚óÜ' : '‚Üí‚óÜ'}
                    </button>
                  ))}
                </div>
              </div>
            )}
          </div>
        );
      };

      return (
        <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #0a0f0a 0%, #1a1f1a 50%, #0f1a0f 100%)', fontFamily: '"JetBrains Mono", monospace', color: '#e0ffe0', padding: isMobile ? '20px 12px' : '40px 20px', position: 'relative', overflow: 'hidden' }}>
          <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 4px)', pointerEvents: 'none', zIndex: 1000 }} />
          <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, backgroundImage: 'linear-gradient(rgba(0,255,100,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,100,0.03) 1px, transparent 1px)', backgroundSize: '50px 50px', pointerEvents: 'none' }} />

          {incomingWhistle && (
            <div style={{ position: 'fixed', top: '20px', left: '50%', transform: 'translateX(-50%)', background: 'rgba(255,200,0,0.2)', border: '2px solid rgba(255,200,0,0.6)', borderRadius: '10px', padding: '15px 30px', zIndex: 2000, animation: 'flashAlert 0.3s ease-in-out infinite' }}>
              <span style={{ fontSize: '13px', letterSpacing: '2px', color: '#ffcc00' }}>‚ö†Ô∏è {incomingWhistle.from.toUpperCase()} ‚Äî {incomingWhistle.type.toUpperCase()} SIGNAL</span>
            </div>
          )}

          <div style={{ maxWidth: '1000px', margin: '0 auto', position: 'relative', zIndex: 1 }}>
            {/* Header */}
            <div style={{ textAlign: 'center', marginBottom: isMobile ? '20px' : '35px' }}>
              <div style={{ display: 'inline-flex', alignItems: 'center', gap: isMobile ? '10px' : '15px', marginBottom: '8px' }}>
                <div style={{ width: isMobile ? '10px' : '12px', height: isMobile ? '10px' : '12px', borderRadius: '50%', background: sessionState !== 'lobby' ? '#00ff66' : '#ff6600', boxShadow: sessionState !== 'lobby' ? '0 0 20px #00ff66' : '0 0 10px #ff6600', animation: sessionState !== 'lobby' ? 'pulse 2s infinite' : 'none' }} />
                <h1 style={{ fontSize: isMobile ? '28px' : '38px', fontWeight: '300', letterSpacing: isMobile ? '4px' : '6px', margin: 0, textShadow: '0 0 30px rgba(0,255,100,0.3)' }}>G-COMMS</h1>
                <div style={{ width: isMobile ? '10px' : '12px', height: isMobile ? '10px' : '12px', borderRadius: '50%', background: sessionState !== 'lobby' ? '#00ff66' : '#ff6600', boxShadow: sessionState !== 'lobby' ? '0 0 20px #00ff66' : '0 0 10px #ff6600', animation: sessionState !== 'lobby' ? 'pulse 2s infinite' : 'none' }} />
              </div>
              <p style={{ fontSize: isMobile ? '9px' : '10px', letterSpacing: isMobile ? '2px' : '3px', color: '#6a9a6a', margin: 0 }}>GBRS COMMUNICATIONS SYSTEM v.0.9.3</p>
            </div>

            {/* Lobby */}
            {sessionState === 'lobby' && (
              <div style={{ maxWidth: '450px', margin: '0 auto', padding: isMobile ? '0' : '0' }}>
                <div style={{ marginBottom: '30px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', marginBottom: '10px' }}>YOUR CALLSIGN</label>
                  <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} placeholder="Enter callsign..." style={{ width: '100%', padding: isMobile ? '18px 20px' : '15px 20px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '16px', outline: 'none', fontFamily: 'inherit' }} />
                </div>
                {error && <div style={{ padding: '12px', background: 'rgba(255,50,50,0.1)', border: '1px solid rgba(255,50,50,0.3)', borderRadius: '6px', color: '#ff6666', fontSize: '12px', marginBottom: '20px', textAlign: 'center' }}>{error}</div>}
                <button onClick={hostSession} style={{ width: '100%', padding: isMobile ? '22px' : '20px', marginBottom: '15px', background: 'linear-gradient(135deg, rgba(0,255,100,0.15), rgba(0,200,80,0.1))', border: '2px solid rgba(0,255,100,0.4)', borderRadius: '12px', color: '#00ff66', fontSize: isMobile ? '15px' : '14px', fontWeight: '600', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>üõ∞Ô∏è HOST NEW SESSION</button>
                <div style={{ textAlign: 'center', padding: '15px 0', color: '#4a6a4a', fontSize: '11px', letterSpacing: '2px' }}>‚Äî OR ‚Äî</div>
                <div style={{ background: 'rgba(0,20,0,0.4)', border: '1px solid rgba(0,255,100,0.15)', borderRadius: '12px', padding: isMobile ? '24px 20px' : '20px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', marginBottom: '10px' }}>SESSION CODE</label>
                  <input type="text" value={joinCode} onChange={(e) => setJoinCode(e.target.value.toUpperCase())} placeholder="XXXXXX" maxLength={6} style={{ width: '100%', padding: isMobile ? '18px' : '15px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '24px', letterSpacing: '8px', outline: 'none', fontFamily: 'inherit', textAlign: 'center', marginBottom: '15px' }} />
                  <button onClick={joinSession} style={{ width: '100%', padding: isMobile ? '18px' : '15px', background: 'transparent', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#8ac88a', fontSize: '12px', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>JOIN SESSION</button>
                </div>
              </div>
            )}

            {/* Session */}
            {(sessionState === 'hosting' || sessionState === 'joined') && (
              <>
                {/* Top Bar */}
                <div style={{ display: 'flex', flexDirection: isMobile ? 'column' : 'row', justifyContent: 'space-between', alignItems: isMobile ? 'stretch' : 'center', padding: isMobile ? '12px' : '12px 18px', background: 'rgba(0,20,0,0.6)', border: '1px solid rgba(0,255,100,0.2)', borderRadius: '10px', marginBottom: '15px', gap: '12px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: isMobile ? '12px' : '20px', flexWrap: 'wrap', justifyContent: isMobile ? 'center' : 'flex-start' }}>
                    <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>SESSION</span>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '4px', justifyContent: isMobile ? 'center' : 'flex-start' }}>
                        <span style={{ fontSize: isMobile ? '16px' : '18px', letterSpacing: '4px', color: '#00ff66', fontWeight: '600' }}>{sessionCode}</span>
                        <button onClick={copyCode} style={{ background: 'rgba(0,255,100,0.1)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '4px', color: '#00ff66', padding: '6px 10px', fontSize: '9px', cursor: 'pointer', fontFamily: 'inherit' }}>COPY</button>
                      </div>
                    </div>
                    {!isMobile && <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />}
                    <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>ROLE</span>
                      <div style={{ fontSize: '12px', marginTop: '4px', color: roleConfig[myRole].color, display: 'flex', alignItems: 'center', gap: '6px', justifyContent: isMobile ? 'center' : 'flex-start' }}>
                        {roleConfig[myRole].icon} {roleConfig[myRole].label}
                      </div>
                    </div>
                    {myRole === 'operator' && myChannelId && (
                      <>
                        {!isMobile && <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />}
                        <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                          <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>CHANNEL</span>
                          <div style={{ fontSize: '12px', marginTop: '4px', color: teams.find(t => t.id === myChannelId)?.color || '#00ff66' }}>
                            {teams.find(t => t.id === myChannelId)?.name.toUpperCase() || 'UNASSIGNED'}
                          </div>
                        </div>
                      </>
                    )}
                    {!isMobile && <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />}
                    <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>STATUS</span>
                      <div style={{ fontSize: '12px', marginTop: '4px', color: statusConfig[myStatus].color }}>{statusConfig[myStatus].icon} {statusConfig[myStatus].label}</div>
                    </div>
                  </div>
                  <div style={{ display: 'flex', gap: '8px', justifyContent: isMobile ? 'center' : 'flex-end' }}>
                    <button onClick={() => setGlobalMute(!globalMute)} style={{ background: globalMute ? 'rgba(255,50,50,0.2)' : 'rgba(0,255,100,0.1)', border: `1px solid ${globalMute ? 'rgba(255,50,50,0.5)' : 'rgba(0,255,100,0.3)'}`, borderRadius: '6px', color: globalMute ? '#ff6666' : '#00ff66', padding: isMobile ? '12px 16px' : '8px 12px', fontSize: '16px', cursor: 'pointer' }}>{globalMute ? 'üîá' : 'üîä'}</button>
                    <button onClick={leaveSession} style={{ background: 'rgba(255,50,50,0.1)', border: '1px solid rgba(255,50,50,0.3)', borderRadius: '6px', color: '#ff6666', padding: isMobile ? '12px 18px' : '8px 14px', fontSize: '10px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>LEAVE</button>
                  </div>
                </div>

                {/* Signals */}
                <div style={{ display: 'flex', gap: '8px', marginBottom: '15px', padding: isMobile ? '12px' : '15px', background: 'rgba(0,20,0,0.4)', border: '1px solid rgba(255,200,0,0.2)', borderRadius: '10px', flexWrap: 'wrap' }}>
                  <span style={{ fontSize: '10px', letterSpacing: '2px', color: '#aa9944', display: 'flex', alignItems: 'center', marginRight: '5px', width: isMobile ? '100%' : 'auto', justifyContent: isMobile ? 'center' : 'flex-start', marginBottom: isMobile ? '8px' : '0' }}>SIGNALS</span>
                  <button onClick={() => broadcastWhistle('attention')} style={{ flex: 1, minWidth: isMobile ? '30%' : '100px', padding: isMobile ? '14px 10px' : '10px 15px', background: 'rgba(255,200,0,0.1)', border: '1px solid rgba(255,200,0,0.4)', borderRadius: '6px', color: '#ffcc00', fontSize: isMobile ? '10px' : '11px', cursor: 'pointer', fontFamily: 'inherit' }}>üìØ ATTN</button>
                  <button onClick={() => broadcastWhistle('alert')} style={{ flex: 1, minWidth: isMobile ? '30%' : '100px', padding: isMobile ? '14px 10px' : '10px 15px', background: 'rgba(255,150,0,0.1)', border: '1px solid rgba(255,150,0,0.4)', borderRadius: '6px', color: '#ff9900', fontSize: isMobile ? '10px' : '11px', cursor: 'pointer', fontFamily: 'inherit' }}>üîî ALERT</button>
                  <button onClick={() => broadcastWhistle('urgent')} style={{ flex: 1, minWidth: isMobile ? '30%' : '100px', padding: isMobile ? '14px 10px' : '10px 15px', background: 'rgba(255,80,80,0.1)', border: '1px solid rgba(255,80,80,0.4)', borderRadius: '6px', color: '#ff6666', fontSize: isMobile ? '10px' : '11px', cursor: 'pointer', fontFamily: 'inherit' }}>‚ö†Ô∏è URGENT</button>
                </div>

                {/* ALL-CALL Panel (Commander only) */}
                {myRole === 'commander' && (
                  <div style={{ background: allCallActive ? 'rgba(255,50,50,0.2)' : 'rgba(0,20,0,0.5)', border: `2px solid ${allCallActive ? 'rgba(255,100,100,0.6)' : 'rgba(0,255,100,0.2)'}`, borderRadius: '10px', padding: isMobile ? '12px' : '15px', marginBottom: '15px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexDirection: isMobile ? 'column' : 'row', gap: '12px' }}>
                      <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                        <span style={{ fontSize: '11px', letterSpacing: '2px', color: '#ffcc00' }}>‚òÖ COMMANDER BROADCAST</span>
                        {!isMobile && <div style={{ fontSize: '9px', color: '#5a7a5a', marginTop: '4px' }}>Ctrl+0: All-Call to ALL squads simultaneously</div>}
                      </div>
                      <button 
                        onClick={() => setAllCallActive(!allCallActive)}
                        style={{ 
                          padding: isMobile ? '16px 32px' : '12px 24px', 
                          background: allCallActive ? 'rgba(255,50,50,0.3)' : 'rgba(255,50,50,0.1)', 
                          border: `2px solid ${allCallActive ? '#ff6666' : 'rgba(255,100,100,0.4)'}`,
                          borderRadius: '8px', 
                          color: allCallActive ? '#ff6666' : '#ff9999', 
                          fontSize: isMobile ? '14px' : '12px', 
                          fontWeight: '600',
                          letterSpacing: '2px', 
                          cursor: 'pointer', 
                          fontFamily: 'inherit',
                          animation: allCallActive ? 'pulse 0.5s infinite' : 'none',
                          width: isMobile ? '100%' : 'auto'
                        }}
                      >
                        üì¢ ALL-CALL {allCallActive ? 'ACTIVE' : 'OFF'}
                      </button>
                    </div>
                  </div>
                )}

                {/* TX Status - Always visible */}
                <div style={{ marginBottom: '15px', padding: '12px 18px', background: isSpeaking ? (allCallActive ? 'rgba(255,50,50,0.2)' : 'rgba(0,100,0,0.3)') : 'rgba(0,20,0,0.4)', border: `1px solid ${isSpeaking ? (allCallActive ? 'rgba(255,100,100,0.4)' : 'rgba(0,255,100,0.4)') : 'rgba(100,100,100,0.2)'}`, borderRadius: '8px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                    <span style={{ fontSize: '10px', letterSpacing: '2px', color: isSpeaking ? (allCallActive ? '#ff6666' : '#00ff66') : '#666' }}>
                      {isSpeaking 
                        ? `üéôÔ∏è TX ‚Üí ${allCallActive ? 'üì¢ ALL SQUADS' : getSpeakingChannels().map(ch => ch === COMMAND_NET_ID ? 'CMD NET' : teams.find(t => t.id === ch)?.name || ch).join(', ') || 'NONE'}`
                        : 'üéôÔ∏è TX OFF ‚Äî Click speak button on a channel'
                      }
                    </span>
                    {isSpeaking && (
                      <>
                        <div style={{ flex: 1, height: '8px', background: 'rgba(0,0,0,0.5)', borderRadius: '4px', overflow: 'hidden' }}>
                          <div style={{ width: `${audioLevel * 100}%`, height: '100%', background: audioLevel > 0.7 ? 'linear-gradient(90deg, #00ff66, #ffff00, #ff3300)' : (allCallActive ? '#ff6666' : '#00ff66'), transition: 'width 0.05s' }} />
                        </div>
                        <span style={{ fontSize: '11px', fontWeight: 'bold', color: audioLevel > 0.7 ? '#ff3300' : (allCallActive ? '#ff6666' : '#00ff66'), minWidth: '35px' }}>{Math.round(audioLevel * 100)}%</span>
                      </>
                    )}
                  </div>
                </div>

                {/* Hotkeys (Desktop) / Status Buttons (Mobile) */}
                {isMobile ? (
                  <div style={{ marginBottom: '15px', padding: '12px', background: 'rgba(0,0,0,0.3)', borderRadius: '8px' }}>
                    <div style={{ fontSize: '9px', color: '#5a7a5a', textAlign: 'center', marginBottom: '10px' }}>SET STATUS</div>
                    <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center' }}>
                      <button onClick={() => broadcastStatus('ready')} style={{ padding: '12px 16px', background: myStatus === 'ready' ? 'rgba(0,255,100,0.2)' : 'rgba(0,0,0,0.3)', border: `1px solid ${myStatus === 'ready' ? '#00ff66' : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: '#00ff66', fontSize: '11px', fontFamily: 'inherit' }}>üü¢ READY</button>
                      <button onClick={() => broadcastStatus('wait')} style={{ padding: '12px 16px', background: myStatus === 'wait' ? 'rgba(255,170,0,0.2)' : 'rgba(0,0,0,0.3)', border: `1px solid ${myStatus === 'wait' ? '#ffaa00' : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: '#ffaa00', fontSize: '11px', fontFamily: 'inherit' }}>üü° WAIT</button>
                      <button onClick={() => broadcastStatus('dead')} style={{ padding: '12px 16px', background: myStatus === 'dead' ? 'rgba(255,50,50,0.2)' : 'rgba(0,0,0,0.3)', border: `1px solid ${myStatus === 'dead' ? '#ff4444' : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: '#ff4444', fontSize: '11px', fontFamily: 'inherit' }}>üî¥ DOWN</button>
                      <button onClick={() => broadcastStatus('standby')} style={{ padding: '12px 16px', background: myStatus === 'standby' ? 'rgba(100,100,100,0.2)' : 'rgba(0,0,0,0.3)', border: `1px solid ${myStatus === 'standby' ? '#666' : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: '#888', fontSize: '11px', fontFamily: 'inherit' }}>‚ö´ STANDBY</button>
                    </div>
                  </div>
                ) : (
                  <div style={{ marginBottom: '15px', padding: '10px 15px', background: 'rgba(0,0,0,0.3)', borderRadius: '6px', display: 'flex', gap: '15px', flexWrap: 'wrap', justifyContent: 'center' }}>
                    <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+M</kbd> Mute</span>
                    <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Shift+A</kbd> Ready</span>
                    <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Alt+D</kbd> Down</span>
                    <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Alt+W</kbd> Wait</span>
                  </div>
                )}

                {/* Unassigned Users (Commander only) */}
                {myRole === 'commander' && getUnassignedUsers().length > 0 && (
                  <div style={{ background: 'rgba(100,50,0,0.2)', border: '1px solid rgba(255,150,0,0.3)', borderRadius: '10px', padding: isMobile ? '12px' : '15px', marginBottom: '15px' }}>
                    <div style={{ fontSize: '10px', letterSpacing: '2px', color: '#ff9900', marginBottom: '10px' }}>
                      ‚ö†Ô∏è UNASSIGNED ‚Äî {isMobile ? 'Tap user, then tap channel' : 'Drag to channel'}
                    </div>
                    <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                      {getUnassignedUsers().map(user => (
                        <div
                          key={user.peerId}
                          draggable={!isMobile}
                          onDragStart={(e) => !isMobile && handleDragStart(e, user)}
                          onDragEnd={() => setDraggedUser(null)}
                          onClick={() => isMobile && setSelectedUserForAssign(selectedUserForAssign?.peerId === user.peerId ? null : user)}
                          className={!isMobile ? "user-chip" : ""}
                          style={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: '8px', 
                            padding: isMobile ? '12px 16px' : '8px 12px', 
                            background: selectedUserForAssign?.peerId === user.peerId ? 'rgba(0,255,100,0.2)' : 'rgba(0,0,0,0.4)', 
                            border: `2px solid ${selectedUserForAssign?.peerId === user.peerId ? '#00ff66' : 'rgba(255,150,0,0.4)'}`, 
                            borderRadius: '6px',
                            cursor: 'pointer'
                          }}
                        >
                          <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: statusConfig[user.status || 'standby'].color }} />
                          <span style={{ fontSize: isMobile ? '12px' : '11px' }}>{user.username.toUpperCase()}</span>
                          {selectedUserForAssign?.peerId === user.peerId && <span style={{ fontSize: '10px', color: '#00ff66' }}>‚úì</span>}
                        </div>
                      ))}
                    </div>
                    {isMobile && selectedUserForAssign && (
                      <div style={{ marginTop: '10px', fontSize: '10px', color: '#00ff66', textAlign: 'center' }}>
                        Now tap a channel below to assign {selectedUserForAssign.username.toUpperCase()}
                      </div>
                    )}
                  </div>
                )}

                {/* Command Net (only visible to commander and squad leaders) */}
                {canSeeCommandNet(myRole) && (
                  <ChannelCard isCommandNet={true} channel={{}} />
                )}

                {/* Create Channel (Commander) */}
                {myRole === 'commander' && (
                  <button onClick={() => setShowCreateModal(true)} style={{ width: '100%', padding: isMobile ? '18px' : '16px', marginBottom: '15px', background: 'transparent', border: '2px dashed rgba(0,255,100,0.3)', borderRadius: '12px', color: '#4a8a4a', fontSize: '12px', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>+ CREATE CHANNEL</button>
                )}

                {/* Squad Channels */}
                {myRole === 'commander' && teams.map(team => (
                  <ChannelCard key={team.id} channel={team} />
                ))}

                {/* Squad Leader view - their squad + command net */}
                {myRole === 'squadleader' && teams.filter(t => t.id === myChannelId).map(team => (
                  <ChannelCard key={team.id} channel={team} />
                ))}

                {/* Operator view - just their squad */}
                {myRole === 'operator' && teams.filter(t => t.id === myChannelId).map(team => (
                  <ChannelCard key={team.id} channel={team} />
                ))}

                {myRole === 'operator' && !myChannelId && (
                  <div style={{ textAlign: 'center', padding: '50px', color: '#ff9900', background: 'rgba(100,50,0,0.2)', borderRadius: '12px', border: '1px solid rgba(255,150,0,0.3)' }}>
                    <p style={{ fontSize: '14px', letterSpacing: '2px', marginBottom: '10px' }}>‚è≥ AWAITING ASSIGNMENT</p>
                    <p style={{ fontSize: '11px', color: '#aa7733' }}>Commander will assign you to a channel</p>
                  </div>
                )}

                {/* Notification when commander is broadcasting ALL-CALL */}
                {connectedUsers.find(u => u.isHost && u.speaking && u.speakingChannels && u.speakingChannels.length > 1) && myRole !== 'commander' && (
                  <div style={{ position: 'fixed', bottom: '20px', left: '50%', transform: 'translateX(-50%)', background: 'rgba(255,50,50,0.2)', border: '2px solid rgba(255,100,100,0.6)', borderRadius: '10px', padding: '12px 24px', zIndex: 2000, animation: 'pulse 0.5s infinite' }}>
                    <span style={{ fontSize: '12px', letterSpacing: '2px', color: '#ff6666' }}>
                      üì¢ COMMANDER ALL-CALL
                    </span>
                  </div>
                )}
              </>
            )}
          </div>

          {/* Create Modal */}
          {showCreateModal && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }} onClick={() => setShowCreateModal(false)}>
              <div style={{ background: 'linear-gradient(135deg, #0f1f0f, #1a2a1a)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '16px', padding: '35px', width: '380px', maxWidth: '90vw' }} onClick={(e) => e.stopPropagation()}>
                <h3 style={{ margin: '0 0 25px 0', fontSize: '14px', letterSpacing: '4px', textAlign: 'center' }}>NEW CHANNEL</h3>
                <input type="text" value={newTeamName} onChange={(e) => setNewTeamName(e.target.value)} placeholder="Channel name..." autoFocus style={{ width: '100%', padding: '14px 18px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '14px', outline: 'none', fontFamily: 'inherit', marginBottom: '18px' }} onKeyDown={(e) => e.key === 'Enter' && createTeam()} />
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '2px', color: '#6a9a6a', marginBottom: '10px' }}>COLOR</label>
                  <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                    {colorOptions.map(color => (<div key={color} onClick={() => setNewTeamColor(color)} style={{ width: '28px', height: '28px', borderRadius: '6px', background: color, cursor: 'pointer', border: newTeamColor === color ? '3px solid white' : '3px solid transparent', boxShadow: newTeamColor === color ? `0 0 15px ${color}` : 'none' }} />))}
                  </div>
                </div>
                <div style={{ display: 'flex', gap: '10px' }}>
                  <button onClick={() => setShowCreateModal(false)} style={{ flex: 1, padding: '12px', background: 'transparent', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '6px', color: '#888', fontSize: '11px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>CANCEL</button>
                  <button onClick={createTeam} style={{ flex: 1, padding: '12px', background: `${newTeamColor}33`, border: `1px solid ${newTeamColor}88`, borderRadius: '6px', color: newTeamColor, fontSize: '11px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>CREATE</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<VoIPApp />);
  </script>
</body>
</html>
