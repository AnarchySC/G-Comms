<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>G-COMMS-BETA | GBRS Communications System v.0.9.4</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“¡</text></svg>">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@nickkell/rnnoise-wasm@0.0.3/dist/index.umd.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
    html, body { 
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      background: linear-gradient(135deg, #0a0f0a 0%, #1a1f1a 50%, #0f1a0f 100%);
      min-height: 100vh;
      min-height: -webkit-fill-available;
      color: #e0ffe0;
      overflow-x: hidden;
      touch-action: manipulation;
    }
    ::placeholder { color: #4a6a4a; }
    input, button { font-size: 16px !important; } /* Prevent iOS zoom */
    button { 
      cursor: pointer; 
      -webkit-touch-callout: none;
      touch-action: manipulation;
    }
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 24px;
      background: transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 4px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #e0ffe0;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0,255,100,0.5);
      margin-top: -8px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #e0ffe0;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(0,255,100,0.5);
    }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes pulseGlow { 0%, 100% { box-shadow: 0 0 10px currentColor; } 50% { box-shadow: 0 0 20px currentColor; } }
    @keyframes glow { 0%, 100% { box-shadow: 0 0 20px rgba(0,255,100,0.2); } 50% { box-shadow: 0 0 30px rgba(0,255,100,0.4); } }
    @keyframes flashAlert { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes soundWave { 0%, 100% { height: 4px; } 50% { height: 16px; } }
    .user-chip { cursor: grab; user-select: none; transition: all 0.2s; padding: 16px !important; min-height: 60px; }
    .user-chip:active { cursor: grabbing; transform: scale(1.05); }
    .user-chip:hover { background: rgba(0,255,100,0.1) !important; border-color: rgba(0,255,100,0.4) !important; }
    .channel-drop-zone { transition: all 0.2s; min-height: 120px; }
    .channel-drop-zone.drag-over { background: rgba(0,255,100,0.15) !important; border-color: rgba(0,255,100,0.6) !important; transform: scale(1.02); }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      .desktop-only { display: none !important; }
    }
    @media (min-width: 769px) {
      .mobile-only { display: none !important; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback, useMemo } = React;

    const COMMAND_NET_ID = 'command-net';
    
    // Detect mobile
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;

    const VoIPApp = () => {
      const [sessionState, setSessionState] = useState('lobby');
      const [sessionCode, setSessionCode] = useState('');
      const [joinCode, setJoinCode] = useState('');
      const [username, setUsername] = useState('');
      const [error, setError] = useState('');
      const [connectedUsers, setConnectedUsers] = useState([]);
      const [myStatus, setMyStatus] = useState('standby');
      const [myChannelId, setMyChannelId] = useState(null);
      const [myRole, setMyRole] = useState('operator'); // operator, squadleader, commander
      
      const [teams, setTeams] = useState([
        { id: 1, name: 'Alpha Squad', volume: 80, color: '#00ff66' },
        { id: 2, name: 'Bravo Unit', volume: 80, color: '#ffcc00' },
      ]);
      const [newTeamName, setNewTeamName] = useState('');
      const [newTeamColor, setNewTeamColor] = useState('#00ff66');
      const [showCreateModal, setShowCreateModal] = useState(false);
      
      // Channel audio states - keyed by channel ID
      const [channelStates, setChannelStates] = useState({});
      // { channelId: { listen: bool, speak: bool }, ... }
      
      const [audioLevel, setAudioLevel] = useState(0);
      const [noiseGateThreshold, setNoiseGateThreshold] = useState(15); // 0-100, default 15%
      const [noiseGateOpen, setNoiseGateOpen] = useState(false);
      const [globalMute, setGlobalMute] = useState(false);
      const [whistleActive, setWhistleActive] = useState(false);
      const [incomingWhistle, setIncomingWhistle] = useState(null);
      const [draggedUser, setDraggedUser] = useState(null);
      const [commandNetVolume, setCommandNetVolume] = useState(80);
      const [allCallActive, setAllCallActive] = useState(false);
      const [selectedUserForAssign, setSelectedUserForAssign] = useState(null); // Mobile: tap user then tap channel
      const [wasKicked, setWasKicked] = useState(false);
      const [wakeLockActive, setWakeLockActive] = useState(false);
      const [connectionHealth, setConnectionHealth] = useState('good'); // good, degraded, reconnecting
      const [reconnectAttempts, setReconnectAttempts] = useState(0);
      const [boardContent, setBoardContent] = useState(''); // Commander's board HTML content
      const [boardExpanded, setBoardExpanded] = useState(true); // Toggle board visibility
      
      const peerRef = useRef(null);
      const reconnectTimeoutRef = useRef(null);
      const heartbeatIntervalRef = useRef(null);
      const lastHeartbeatRef = useRef(new Map()); // peerId -> timestamp
      const connectionsRef = useRef(new Map());
      const localStreamRef = useRef(null);
      const audioContextRef = useRef(null);
      const analyserRef = useRef(null);
      const gainNodeRef = useRef(null);
      const processedStreamRef = useRef(null);
      const noiseSuppressionRef = useRef(null); // Holds filter chain
      const gainNodesRef = useRef(new Map()); // peerId -> gain node for remote audio
      const animationRef = useRef(null);
      const isHostRef = useRef(false);
      const audioElementsRef = useRef(new Map()); // peerId -> Audio element
      const teamsRef = useRef(teams);
      const myStatusRef = useRef(myStatus);
      const myChannelIdRef = useRef(myChannelId);
      const myRoleRef = useRef(myRole);
      const connectedUsersRef = useRef(connectedUsers);
      const channelStatesRef = useRef(channelStates);
      const allCallActiveRef = useRef(allCallActive);
      const wakeLockRef = useRef(null);
      const boardContentRef = useRef(boardContent);
      const boardEditorRef = useRef(null);

      // Wake Lock - prevent screen from sleeping during session
      const requestWakeLock = async () => {
        if ('wakeLock' in navigator) {
          try {
            wakeLockRef.current = await navigator.wakeLock.request('screen');
            setWakeLockActive(true);
            console.log('Wake lock active - screen will stay on');
            wakeLockRef.current.addEventListener('release', () => {
              setWakeLockActive(false);
              console.log('Wake lock released');
            });
          } catch (err) {
            console.log('Wake lock failed:', err.message);
          }
        } else {
          console.log('Wake Lock API not supported');
        }
      };

      const releaseWakeLock = () => {
        if (wakeLockRef.current) {
          wakeLockRef.current.release();
          wakeLockRef.current = null;
          setWakeLockActive(false);
        }
      };

      useEffect(() => { teamsRef.current = teams; }, [teams]);
      useEffect(() => { myStatusRef.current = myStatus; }, [myStatus]);
      useEffect(() => { myChannelIdRef.current = myChannelId; }, [myChannelId]);
      useEffect(() => { myRoleRef.current = myRole; }, [myRole]);
      useEffect(() => { connectedUsersRef.current = connectedUsers; }, [connectedUsers]);
      useEffect(() => { channelStatesRef.current = channelStates; }, [channelStates]);
      useEffect(() => { allCallActiveRef.current = allCallActive; }, [allCallActive]);
      useEffect(() => { boardContentRef.current = boardContent; }, [boardContent]);
      // Sync board content to editor when received from host (but not when we're editing)
      useEffect(() => {
        if (boardEditorRef.current && document.activeElement !== boardEditorRef.current) {
          boardEditorRef.current.innerHTML = boardContent;
        }
      }, [boardContent]);

      // Re-acquire wake lock when tab becomes visible again
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (document.visibilityState === 'visible' && sessionState !== 'lobby') {
            requestWakeLock();
          }
        };
        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
      }, [sessionState]);

      // Check if currently speaking on any channel
      const isSpeaking = useMemo(() => {
        if (globalMute) return false;
        if (allCallActive && myRole === 'commander') return true;
        if (!channelStates || Object.keys(channelStates).length === 0) return false;
        return Object.values(channelStates).some(s => s && s.speak === true);
      }, [globalMute, allCallActive, myRole, channelStates]);
      
      // Get channels I'm speaking to
      const getSpeakingChannels = useCallback(() => {
        if (globalMute) return [];
        
        // If ALL-CALL is active (commander only), return all squad channels
        if (allCallActive && myRoleRef.current === 'commander') {
          return teamsRef.current.map(t => t.id);
        }
        
        if (!channelStates || Object.keys(channelStates).length === 0) {
          return [];
        }
        
        const channels = [];
        Object.entries(channelStates).forEach(([id, state]) => {
          if (state && state.speak) {
            channels.push(id === COMMAND_NET_ID ? COMMAND_NET_ID : parseInt(id));
          }
        });
        return channels;
      }, [channelStates, globalMute, allCallActive]);

      const colorOptions = [
        '#00ff66', '#ffcc00', '#ff6b6b', '#4ecdc4', '#a855f7', 
        '#3b82f6', '#f97316', '#ec4899', '#84cc16', '#06b6d4'
      ];

      const statusConfig = {
        standby: { color: '#666666', label: 'STANDBY', icon: 'âš«' },
        ready: { color: '#00ff66', label: 'READY', icon: 'ðŸŸ¢' },
        dead: { color: '#ff4444', label: 'DOWN', icon: 'ðŸ”´' },
        wait: { color: '#ffaa00', label: 'WAIT ONE', icon: 'ðŸŸ¡' }
      };

      const roleConfig = {
        operator: { label: 'OPERATOR', color: '#00ff66', icon: 'â—' },
        squadleader: { label: 'SQUAD LEADER', color: '#4ecdc4', icon: 'â—†' },
        commander: { label: 'COMMANDER', color: '#ffcc00', icon: 'â˜…' }
      };

      // Check if user can see command net
      const canSeeCommandNet = (role) => role === 'commander' || role === 'squadleader';

      // Get channels visible to current user
      const getVisibleChannels = () => {
        if (myRole === 'commander') {
          return teams; // Commander sees all squad channels
        } else if (myRole === 'squadleader') {
          return teams.filter(t => t.id === myChannelId); // Squad leader sees their squad
        } else {
          return teams.filter(t => t.id === myChannelId); // Operator sees their squad
        }
      };

      // Update audio routing - determines who we hear
      const updateAudioRouting = useCallback(() => {
        console.log('Updating audio routing, users:', connectedUsersRef.current.length);
        
        connectedUsersRef.current.forEach(user => {
          if (user.peerId === peerRef.current?.id) return;
          
          const audioEl = audioElementsRef.current.get(user.peerId);
          if (!audioEl) {
            console.log('No audio element for', user.username);
            return;
          }
          
          let shouldHear = false;
          let volume = 0.8;
          
          // Check if we should hear this user based on their speaking channels and our listening channels
          if (user.speaking && user.speakingChannels && user.speakingChannels.length > 0) {
            console.log(user.username, 'is speaking on channels:', user.speakingChannels);
            console.log('My channel states:', channelStatesRef.current);
            
            for (const speakingCh of user.speakingChannels) {
              // Check both string and number versions of channel ID
              const chState = channelStatesRef.current[speakingCh] || channelStatesRef.current[String(speakingCh)];
              console.log('Checking channel', speakingCh, 'state:', chState);
              
              if (chState?.listen) {
                shouldHear = true;
                // Get volume for this channel
                if (speakingCh === COMMAND_NET_ID) {
                  volume = commandNetVolume / 100;
                } else {
                  const team = teamsRef.current.find(t => t.id === speakingCh || t.id === parseInt(speakingCh));
                  if (team) volume = team.volume / 100;
                }
                break;
              }
            }
          }
          
          if (globalMute) shouldHear = false;
          
          console.log('Should hear', user.username, ':', shouldHear, 'volume:', volume);
          audioEl.muted = !shouldHear;
          audioEl.volume = volume;
        });
      }, [globalMute, commandNetVolume]);

      useEffect(() => {
        updateAudioRouting();
      }, [connectedUsers, channelStates, globalMute, teams, updateAudioRouting]);

      const broadcastStatus = useCallback((newStatus) => {
        setMyStatus(newStatus);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'status-update', peerId: peerRef.current?.id, status: newStatus });
          }
        });
      }, []);

      const broadcastSpeakingState = useCallback((speakingChannels) => {
        console.log('Broadcasting speaking state, channels:', speakingChannels);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ 
              type: 'speaking-update', 
              peerId: peerRef.current?.id, 
              speaking: speakingChannels.length > 0,
              speakingChannels: speakingChannels
            });
          }
        });
      }, []);

      useEffect(() => {
        if (sessionState !== 'lobby') {
          const channels = getSpeakingChannels();
          broadcastSpeakingState(channels);
        }
      }, [channelStates, sessionState, globalMute, allCallActive, getSpeakingChannels, broadcastSpeakingState]);

      // Toggle channel listen/speak
      const toggleChannelListen = (channelId) => {
        setChannelStates(prev => ({
          ...prev,
          [channelId]: { ...prev[channelId], listen: !prev[channelId]?.listen }
        }));
      };

      const toggleChannelSpeak = (channelId) => {
        setChannelStates(prev => ({
          ...prev,
          [channelId]: { ...prev[channelId], speak: !prev[channelId]?.speak }
        }));
      };

      // Promote user to squad leader (host only)
      const promoteToSquadLeader = useCallback((userId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, role: 'squadleader' } : u
        ));
        
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'role-update', peerId: userId, role: 'squadleader' });
          }
        });
      }, []);

      // Demote squad leader to operator (host only)
      const demoteToOperator = useCallback((userId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, role: 'operator' } : u
        ));
        
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'role-update', peerId: userId, role: 'operator' });
          }
        });
      }, []);

      // Kick user from session (host only)
      const kickUser = useCallback((userId, username) => {
        if (!isHostRef.current) return;
        
        // Send kick message to the user being kicked
        const userConn = connectionsRef.current.get(userId);
        if (userConn?.conn?.open) {
          userConn.conn.send({ type: 'kicked', reason: 'Removed by commander' });
          setTimeout(() => {
            userConn.conn.close();
          }, 100);
        }
        
        // Remove from local state
        setConnectedUsers(prev => prev.filter(u => u.peerId !== userId));
        
        // Notify all other users
        connectionsRef.current.forEach((connData, peerId) => {
          if (peerId !== userId && connData.conn?.open) {
            connData.conn.send({ type: 'user-left', peerId: userId });
          }
        });
        
        // Clean up connection
        connectionsRef.current.delete(userId);
        gainNodesRef.current.delete(userId);
      }, []);

      // Move user to channel (host only)
      const moveUserToChannel = useCallback((userId, channelId) => {
        if (!isHostRef.current) return;
        
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === userId ? { ...u, channelId } : u
        ));
        
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'user-moved', peerId: userId, channelId });
          }
        });
        
        if (userId === peerRef.current?.id) {
          setMyChannelId(channelId);
        }
      }, []);

      const playWhistle = useCallback((type = 'attention') => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        if (type === 'attention') {
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(800, ctx.currentTime);
          oscillator.frequency.linearRampToValueAtTime(1600, ctx.currentTime + 0.3);
          oscillator.frequency.linearRampToValueAtTime(1200, ctx.currentTime + 0.6);
          gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
          gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.7);
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.7);
        } else if (type === 'alert') {
          oscillator.type = 'square';
          oscillator.frequency.setValueAtTime(1000, ctx.currentTime);
          gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
          gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.1);
          gainNode.gain.setValueAtTime(0.2, ctx.currentTime + 0.15);
          gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.25);
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.3);
        } else if (type === 'urgent') {
          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(1200, ctx.currentTime);
          gainNode.gain.setValueAtTime(0.15, ctx.currentTime);
          for (let i = 0; i < 3; i++) {
            const t = ctx.currentTime + i * 0.15;
            gainNode.gain.setValueAtTime(0.15, t);
            gainNode.gain.setValueAtTime(0, t + 0.1);
          }
          oscillator.start(ctx.currentTime);
          oscillator.stop(ctx.currentTime + 0.5);
        }
      }, []);

      const broadcastWhistle = useCallback((type) => {
        playWhistle(type);
        setWhistleActive(true);
        setTimeout(() => setWhistleActive(false), 800);
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) connData.conn.send({ type: 'whistle', whistleType: type, from: username });
        });
      }, [playWhistle, username]);

      // Hotkeys
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (sessionState === 'lobby') return;
          if (e.target.tagName === 'INPUT') return;
          
          if (e.ctrlKey && e.shiftKey && (e.key === 'A' || e.key === 'a')) {
            e.preventDefault(); broadcastStatus('ready'); return;
          }
          if (e.ctrlKey && e.altKey && (e.key === 'd' || e.key === 'D')) {
            e.preventDefault(); broadcastStatus('dead'); return;
          }
          if (e.ctrlKey && e.altKey && (e.key === 'w' || e.key === 'W')) {
            e.preventDefault(); broadcastStatus('wait'); return;
          }
          if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'm') {
            e.preventDefault(); setGlobalMute(prev => !prev); return;
          }
          if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'w') {
            e.preventDefault(); broadcastWhistle('attention'); return;
          }
          // Ctrl+0 - Toggle ALL-CALL (commander only)
          if (e.ctrlKey && e.key === '0' && myRoleRef.current === 'commander') {
            e.preventDefault();
            setAllCallActive(prev => !prev);
            return;
          }
          // Ctrl+` - Toggle Command Net listen (if visible)
          if (e.ctrlKey && e.key === '`' && canSeeCommandNet(myRoleRef.current)) {
            e.preventDefault();
            toggleChannelListen(COMMAND_NET_ID);
            return;
          }
          // Ctrl+Shift+0 - Toggle Command Net speak (if visible)
          if (e.ctrlKey && e.shiftKey && e.key === ')' && canSeeCommandNet(myRoleRef.current)) {
            e.preventDefault();
            toggleChannelSpeak(COMMAND_NET_ID);
            return;
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [sessionState, broadcastWhistle, broadcastStatus]);

      const generateCode = () => {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
        return code;
      };

      const initPeer = useCallback((peerId) => {
        return new Promise((resolve, reject) => {
          const peer = new Peer(peerId, { 
            debug: 1,
            config: {
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                // Free TURN servers from Open Relay (metered.ca)
                {
                  urls: 'turn:a.relay.metered.ca:80',
                  username: 'e8dd65caa142a36b1f4b0a99',
                  credential: 'kIcSIx5h3xf3AoHn'
                },
                {
                  urls: 'turn:a.relay.metered.ca:80?transport=tcp',
                  username: 'e8dd65caa142a36b1f4b0a99',
                  credential: 'kIcSIx5h3xf3AoHn'
                },
                {
                  urls: 'turn:a.relay.metered.ca:443',
                  username: 'e8dd65caa142a36b1f4b0a99',
                  credential: 'kIcSIx5h3xf3AoHn'
                },
                {
                  urls: 'turn:a.relay.metered.ca:443?transport=tcp',
                  username: 'e8dd65caa142a36b1f4b0a99',
                  credential: 'kIcSIx5h3xf3AoHn'
                }
              ],
              iceCandidatePoolSize: 10
            }
          });
          peer.on('open', (id) => { 
            console.log('Connected:', id); 
            setConnectionHealth('good');
            setReconnectAttempts(0);
            resolve(peer); 
          });
          peer.on('error', (err) => {
            console.error('Peer error:', err.type, err);
            if (err.type === 'unavailable-id') reject(new Error('Session code already in use'));
            else if (err.type === 'peer-unavailable') reject(new Error('Session not found'));
            else if (err.type === 'disconnected' || err.type === 'network') {
              setConnectionHealth('reconnecting');
              // Will be handled by reconnection logic
            }
            else reject(err);
          });
          peer.on('disconnected', () => {
            console.log('Peer disconnected, attempting reconnect...');
            setConnectionHealth('reconnecting');
            if (!peer.destroyed) {
              peer.reconnect();
            }
          });
          peerRef.current = peer;
        });
      }, []);

      const getLocalStream = useCallback(async () => {
        if (!processedStreamRef.current) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                echoCancellation: { ideal: true },
                noiseSuppression: { ideal: true },
                autoGainControl: { ideal: true },
                channelCount: { ideal: 1 }
              }
            });
            localStreamRef.current = stream;

            // Set up audio processing pipeline
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContextRef.current.createMediaStreamSource(stream);
            const ctx = audioContextRef.current;

            // === NOISE SUPPRESSION CHAIN ===
            let audioInput = source; // Start with source, may be replaced by RNNoise output

            // 0. RNNoise AI noise suppression (if available)
            try {
              if (window.RnnoiseWasm && window.RnnoiseWasm.createRnnoiseNode) {
                const rnnoiseNode = await window.RnnoiseWasm.createRnnoiseNode(ctx);
                source.connect(rnnoiseNode);
                audioInput = rnnoiseNode;
                console.log('[Audio] RNNoise AI noise suppression enabled');
              } else {
                console.log('[Audio] RNNoise not available, using fallback filters');
              }
            } catch (rnnoiseErr) {
              console.warn('[Audio] RNNoise failed to initialize:', rnnoiseErr);
            }

            // 1. High-pass filter - removes low frequency rumble (AC hum, fans, traffic)
            const highPass = ctx.createBiquadFilter();
            highPass.type = 'highpass';
            highPass.frequency.value = 85;  // Cut below 85Hz (voice starts ~85Hz)
            highPass.Q.value = 0.7;

            // 2. Low-pass filter - removes high frequency hiss
            const lowPass = ctx.createBiquadFilter();
            lowPass.type = 'lowpass';
            lowPass.frequency.value = 8000;  // Cut above 8kHz (voice intelligibility range)
            lowPass.Q.value = 0.7;

            // 3. Notch filter - removes 60Hz electrical hum (and harmonics)
            const notch60 = ctx.createBiquadFilter();
            notch60.type = 'notch';
            notch60.frequency.value = 60;
            notch60.Q.value = 30;

            const notch120 = ctx.createBiquadFilter();
            notch120.type = 'notch';
            notch120.frequency.value = 120;  // 2nd harmonic
            notch120.Q.value = 30;

            // 4. Compressor - normalizes levels and reduces dynamic range
            const compressor = ctx.createDynamicsCompressor();
            compressor.threshold.value = -24;   // Start compressing at -24dB
            compressor.knee.value = 12;          // Soft knee for natural sound
            compressor.ratio.value = 4;          // 4:1 compression ratio
            compressor.attack.value = 0.003;     // Fast attack (3ms)
            compressor.release.value = 0.15;     // Medium release (150ms)

            // 5. Makeup gain after compression
            const makeupGain = ctx.createGain();
            makeupGain.gain.value = 1.5;  // Boost to compensate for compression

            // Store refs for potential future control
            noiseSuppressionRef.current = { highPass, lowPass, notch60, notch120, compressor, makeupGain };

            // Connect the noise suppression chain (audioInput is either source or RNNoise output)
            audioInput.connect(highPass);
            highPass.connect(lowPass);
            lowPass.connect(notch60);
            notch60.connect(notch120);
            notch120.connect(compressor);
            compressor.connect(makeupGain);

            // Analyser for level metering (receives cleaned audio)
            analyserRef.current = ctx.createAnalyser();
            analyserRef.current.fftSize = 256;
            makeupGain.connect(analyserRef.current);

            // Gain node for noise gate control
            gainNodeRef.current = ctx.createGain();
            gainNodeRef.current.gain.value = 0; // Start muted
            makeupGain.connect(gainNodeRef.current);

            // Create processed stream for peer connections
            const destination = ctx.createMediaStreamDestination();
            gainNodeRef.current.connect(destination);
            processedStreamRef.current = destination.stream;

            console.log('[Audio] Noise suppression chain initialized');
            return processedStreamRef.current;
          } catch (err) {
            setError('Microphone access required');
            return null;
          }
        }
        return processedStreamRef.current;
      }, []);

      useEffect(() => {
        let animFrame;
        if (isSpeaking && analyserRef.current && localStreamRef.current) {
          const updateLevel = () => {
            const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
            analyserRef.current.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const level = avg / 255;
            setAudioLevel(level);

            // Noise gate logic: only open gate if level exceeds threshold
            const threshold = noiseGateThreshold / 100;
            const isAboveThreshold = level > threshold;
            setNoiseGateOpen(isAboveThreshold);

            // Control audio output via gain node (not track.enabled)
            if (gainNodeRef.current) {
              gainNodeRef.current.gain.value = isAboveThreshold ? 1 : 0;
            }

            animFrame = requestAnimationFrame(updateLevel);
          };
          updateLevel();
        } else {
          setAudioLevel(0);
          setNoiseGateOpen(false);
          // Mute output when not speaking (PTT released)
          if (gainNodeRef.current) {
            gainNodeRef.current.gain.value = 0;
          }
        }
        return () => {
          if (animFrame) cancelAnimationFrame(animFrame);
        };
      }, [isSpeaking, noiseGateThreshold]);

      // Note: Audio output is controlled via gainNodeRef in the useEffect above

      const handleData = useCallback((data, fromPeerId) => {
        console.log('Received:', data.type, 'from:', fromPeerId);
        
        // Update heartbeat timestamp
        if (data.type === 'heartbeat' || data.type === 'heartbeat-ack') {
          lastHeartbeatRef.current.set(fromPeerId, Date.now());
          if (data.type === 'heartbeat') {
            // Respond to heartbeat
            const conn = connectionsRef.current.get(fromPeerId)?.conn;
            if (conn?.open) {
              conn.send({ type: 'heartbeat-ack', timestamp: data.timestamp });
            }
          }
          return;
        }
        
        if (data.type === 'whistle') {
          playWhistle(data.whistleType);
          setIncomingWhistle({ type: data.whistleType, from: data.from });
          setTimeout(() => setIncomingWhistle(null), 2000);
        } else if (data.type === 'status-update') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, status: data.status } : u));
        } else if (data.type === 'speaking-update') {
          console.log('Received speaking update:', data.peerId, 'speaking:', data.speaking, 'channels:', data.speakingChannels);
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { 
            ...u, 
            speaking: data.speaking,
            speakingChannels: data.speakingChannels || []
          } : u));
        } else if (data.type === 'role-update') {
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, role: data.role } : u));
          if (data.peerId === peerRef.current?.id) {
            setMyRole(data.role);
            // If promoted to squad leader, enable command net listening by default
            if (data.role === 'squadleader') {
              setChannelStates(prev => ({
                ...prev,
                [COMMAND_NET_ID]: { listen: true, speak: false }
              }));
            }
          }
        } else if (data.type === 'user-moved') {
          console.log('User moved:', data.peerId, 'to channel:', data.channelId);
          setConnectedUsers(prev => prev.map(u => u.peerId === data.peerId ? { ...u, channelId: data.channelId } : u));
          if (data.peerId === peerRef.current?.id) {
            console.log('I was moved to channel:', data.channelId);
            setMyChannelId(data.channelId);
            // Enable listen/speak on assigned channel
            setChannelStates(prev => {
              const newState = {
                ...prev,
                [data.channelId]: { listen: true, speak: true }
              };
              console.log('New channelStates:', newState);
              return newState;
            });
          }
        } else if (data.type === 'user-joined') {
          // Create the new user object (always unassigned when joining)
          const newUser = { 
            peerId: data.peerId, 
            username: data.username, 
            status: data.status || 'standby', 
            speaking: false,
            speakingChannels: [],
            channelId: null,  // Always start unassigned
            role: 'operator',
            isHost: data.isHost || false
          };
          
          // Add to connected users if not already present
          setConnectedUsers(prev => {
            if (!prev.find(u => u.peerId === data.peerId)) {
              return [...prev, newUser];
            }
            return prev;
          });
          
          // Host-specific: send sync state to new user and notify others
          if (isHostRef.current) {
            const conn = connectionsRef.current.get(fromPeerId)?.conn;
            if (conn?.open) {
              // Build users list including the new user
              const currentUsers = connectedUsersRef.current.filter(u => u.peerId !== data.peerId);
              const allUsers = [...currentUsers, newUser];
              
              conn.send({
                type: 'sync-state',
                teams: teamsRef.current,
                users: allUsers,
                yourChannelId: null,
                yourRole: 'operator',
                boardContent: boardContentRef.current
              });
            }
            
            // Notify other connected users
            connectionsRef.current.forEach((connData, peerId) => {
              if (peerId !== fromPeerId && connData.conn?.open) {
                connData.conn.send({ 
                  type: 'user-joined', 
                  ...newUser
                });
              }
            });
          }
        } else if (data.type === 'sync-state') {
          setTeams(data.teams);
          // Ensure all users have required fields
          const usersWithDefaults = data.users.map(u => ({
            ...u,
            speaking: u.speaking || false,
            speakingChannels: u.speakingChannels || [],
            status: u.status || 'standby',
            role: u.role || 'operator'
          }));
          setConnectedUsers(usersWithDefaults);
          setMyChannelId(data.yourChannelId);
          setMyRole(data.yourRole || 'operator');
          // Set up initial channel states only if assigned to a channel
          if (data.yourChannelId !== null && data.yourChannelId !== undefined) {
            setChannelStates(prev => ({
              ...prev,
              [data.yourChannelId]: { listen: true, speak: true }
            }));
          }
          if (data.boardContent) {
            setBoardContent(data.boardContent);
          }
        } else if (data.type === 'teams-update') {
          setTeams(data.teams);
        } else if (data.type === 'board-update') {
          setBoardContent(data.content);
        } else if (data.type === 'user-left') {
          setConnectedUsers(prev => prev.filter(u => u.peerId !== data.peerId));
        } else if (data.type === 'kicked') {
          // We've been kicked - set flag to trigger cleanup
          setWasKicked(true);
        }
      }, [playWhistle]);

      const setupConnection = useCallback((conn) => {
        conn.on('open', async () => {
          console.log('Connection opened:', conn.peer);
          connectionsRef.current.set(conn.peer, { ...connectionsRef.current.get(conn.peer), conn });
          conn.send({ 
            type: 'user-joined', 
            peerId: peerRef.current.id, 
            username: username, 
            status: myStatusRef.current,
            channelId: myChannelIdRef.current,
            role: myRoleRef.current,
            isHost: isHostRef.current
          });
          const stream = await getLocalStream();
          if (stream && peerRef.current) {
            const call = peerRef.current.call(conn.peer, stream);
            setupCall(call);
          }
        });
        conn.on('data', (data) => handleData(data, conn.peer));
        conn.on('close', () => {
          console.log('Connection closed:', conn.peer);
          const audioEl = audioElementsRef.current.get(conn.peer);
          if (audioEl) {
            audioEl.srcObject = null;
            audioEl.remove();
            audioElementsRef.current.delete(conn.peer);
          }
          connectionsRef.current.delete(conn.peer);
          lastHeartbeatRef.current.delete(conn.peer);
          setConnectedUsers(prev => prev.filter(u => u.peerId !== conn.peer));
          
          // Auto-reconnect for non-host peers who lost connection to host
          if (!isHostRef.current && conn.peer.includes('-host') && sessionState !== 'lobby') {
            console.log('Lost connection to host, attempting reconnect...');
            setConnectionHealth('reconnecting');
            attemptReconnect();
          }
        });
      }, [username, getLocalStream, handleData]);

      const setupCall = useCallback((call) => {
        call.on('stream', async (remoteStream) => {
          console.log('Got audio stream from:', call.peer);

          // Create or get audio element for this peer
          let audioEl = audioElementsRef.current.get(call.peer);
          if (!audioEl) {
            audioEl = new Audio();
            audioEl.autoplay = true;
            audioEl.muted = true; // Start muted, updateAudioRouting will unmute if needed
            audioElementsRef.current.set(call.peer, audioEl);
          }

          // === RECEIVE-SIDE NOISE SUPPRESSION ===
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const source = ctx.createMediaStreamSource(remoteStream);
            let audioInput = source;

            // Try to use RNNoise for incoming audio
            try {
              if (window.RnnoiseWasm && window.RnnoiseWasm.createRnnoiseNode) {
                const rnnoiseNode = await window.RnnoiseWasm.createRnnoiseNode(ctx);
                source.connect(rnnoiseNode);
                audioInput = rnnoiseNode;
                console.log('[Audio] RNNoise enabled for incoming audio from:', call.peer);
              }
            } catch (e) {
              console.warn('[Audio] RNNoise failed for incoming:', e);
            }

            // Apply filters to incoming audio
            const highPass = ctx.createBiquadFilter();
            highPass.type = 'highpass';
            highPass.frequency.value = 85;
            highPass.Q.value = 0.7;

            const lowPass = ctx.createBiquadFilter();
            lowPass.type = 'lowpass';
            lowPass.frequency.value = 8000;
            lowPass.Q.value = 0.7;

            // Connect: input -> highpass -> lowpass -> destination
            audioInput.connect(highPass);
            highPass.connect(lowPass);

            const destination = ctx.createMediaStreamDestination();
            lowPass.connect(destination);

            // Use processed stream instead of raw remote stream
            audioEl.srcObject = destination.stream;
            console.log('[Audio] Receive-side noise suppression active for:', call.peer);
          } catch (err) {
            // Fallback to raw stream if processing fails
            console.warn('[Audio] Receive processing failed, using raw stream:', err);
            audioEl.srcObject = remoteStream;
          }

          audioEl.play().catch(e => console.log('Audio play error:', e));

          connectionsRef.current.set(call.peer, { ...connectionsRef.current.get(call.peer), stream: remoteStream });

          // Trigger routing update after a short delay
          setTimeout(() => updateAudioRouting(), 100);
        });

        call.on('error', (err) => {
          console.error('Call error:', err);
        });
      }, [updateAudioRouting]);

      const hostSession = async () => {
        if (!username.trim()) { setError('Please enter your callsign'); return; }
        setError('');
        const code = generateCode();
        try {
          // Get mic access first
          const stream = await getLocalStream();
          if (!stream) {
            setError('Microphone access required');
            return;
          }
          console.log('Got local stream for host');
          
          const peer = await initPeer(`gcomms-${code}-host`);
          peer.on('connection', (conn) => { console.log('Incoming:', conn.peer); setupConnection(conn); });
          peer.on('call', async (call) => {
            const stream = await getLocalStream();
            if (stream) { call.answer(stream); setupCall(call); }
          });
          isHostRef.current = true;
          setSessionCode(code);
          setSessionState('hosting');
          setMyRole('commander');
          requestWakeLock(); // Keep screen on
          // Commander starts with command net and all channels listen enabled
          const initialStates = { [COMMAND_NET_ID]: { listen: true, speak: false } };
          teams.forEach(t => { initialStates[t.id] = { listen: true, speak: false }; });
          setChannelStates(initialStates);
          setConnectedUsers([{ 
            peerId: peer.id, 
            username: username, 
            isHost: true, 
            status: 'standby', 
            speaking: false,
            speakingChannels: [],
            channelId: null,
            role: 'commander'
          }]);
        } catch (err) { setError(err.message); }
      };

      const joinSession = async () => {
        if (!username.trim()) { setError('Please enter your callsign'); return; }
        if (!joinCode.trim()) { setError('Please enter a session code'); return; }
        setError('');
        const code = joinCode.toUpperCase().replace(/[^A-Z0-9]/g, '');
        const uniqueId = `gcomms-${code}-${Date.now()}`;
        try {
          // Get mic access first
          const stream = await getLocalStream();
          if (!stream) {
            setError('Microphone access required');
            return;
          }
          console.log('Got local stream for joiner');
          
          const peer = await initPeer(uniqueId);
          peer.on('connection', (conn) => setupConnection(conn));
          peer.on('call', async (call) => {
            const stream = await getLocalStream();
            if (stream) { call.answer(stream); setupCall(call); }
          });
          const hostPeerId = `gcomms-${code}-host`;
          const conn = peer.connect(hostPeerId, { reliable: true });
          conn.on('error', () => setError('Failed to connect'));
          setupConnection(conn);
          isHostRef.current = false;
          setSessionCode(code);
          setSessionState('joined');
          setMyRole('operator');
          requestWakeLock(); // Keep screen on
          setConnectedUsers([{ peerId: peer.id, username: username, status: 'standby', speaking: false, speakingChannels: [], channelId: null, role: 'operator' }]);
        } catch (err) { setError(err.message); }
      };

      const leaveSession = () => {
        // Clear reconnect timeout if leaving intentionally
        if (reconnectTimeoutRef.current) {
          clearTimeout(reconnectTimeoutRef.current);
          reconnectTimeoutRef.current = null;
        }
        connectionsRef.current.forEach((connData) => {
          if (connData.conn?.open) {
            connData.conn.send({ type: 'user-left', peerId: peerRef.current?.id });
            connData.conn.close();
          }
        });
        connectionsRef.current.clear();
        gainNodesRef.current.clear();
        lastHeartbeatRef.current.clear();
        // Clean up audio elements
        audioElementsRef.current.forEach(audioEl => {
          audioEl.srcObject = null;
          audioEl.remove();
        });
        audioElementsRef.current.clear();
        if (localStreamRef.current) { localStreamRef.current.getTracks().forEach(track => track.stop()); localStreamRef.current = null; }
        if (processedStreamRef.current) { processedStreamRef.current = null; }
        if (audioContextRef.current) { audioContextRef.current.close(); audioContextRef.current = null; }
        gainNodeRef.current = null;
        analyserRef.current = null;
        noiseSuppressionRef.current = null;
        if (peerRef.current) { peerRef.current.destroy(); peerRef.current = null; }
        setSessionState('lobby');
        setSessionCode('');
        setConnectedUsers([]);
        setMyChannelId(null);
        setMyRole('operator');
        setMyStatus('standby');
        setChannelStates({});
        setAllCallActive(false);
        setBoardContent('');
        setConnectionHealth('good');
        setReconnectAttempts(0);
        isHostRef.current = false;
        releaseWakeLock(); // Allow screen to sleep again
        // Clear any pending heartbeat intervals
        if (heartbeatIntervalRef.current) {
          clearInterval(heartbeatIntervalRef.current);
          heartbeatIntervalRef.current = null;
        }
      };

      // Auto-reconnect with exponential backoff
      const attemptReconnect = useCallback(async () => {
        const maxAttempts = 5;
        const currentAttempt = reconnectAttempts + 1;
        
        if (currentAttempt > maxAttempts) {
          console.log('Max reconnect attempts reached');
          setError('Connection lost. Please rejoin the session.');
          setConnectionHealth('good');
          setSessionState('lobby');
          return;
        }
        
        setReconnectAttempts(currentAttempt);
        const backoffMs = Math.min(1000 * Math.pow(2, currentAttempt - 1), 10000); // 1s, 2s, 4s, 8s, 10s
        console.log(`Reconnect attempt ${currentAttempt}/${maxAttempts} in ${backoffMs}ms`);
        
        reconnectTimeoutRef.current = setTimeout(async () => {
          try {
            const hostPeerId = `gcomms-${sessionCode}-host`;
            const conn = peerRef.current.connect(hostPeerId, { reliable: true });
            
            conn.on('open', () => {
              console.log('Reconnected to host!');
              setConnectionHealth('good');
              setReconnectAttempts(0);
              setupConnection(conn);
            });
            
            conn.on('error', (err) => {
              console.log('Reconnect failed:', err);
              attemptReconnect();
            });
            
            // Timeout for this attempt
            setTimeout(() => {
              if (!conn.open) {
                console.log('Reconnect attempt timed out');
                conn.close();
                attemptReconnect();
              }
            }, 5000);
            
          } catch (err) {
            console.log('Reconnect error:', err);
            attemptReconnect();
          }
        }, backoffMs);
      }, [reconnectAttempts, sessionCode, setupConnection]);

      // Handle being kicked
      useEffect(() => {
        if (wasKicked) {
          alert('You have been removed from the session by the commander.');
          leaveSession();
          setWasKicked(false);
        }
      }, [wasKicked]);

      // Heartbeat system for connection health monitoring
      useEffect(() => {
        if (sessionState === 'lobby') return;
        
        // Send heartbeat every 3 seconds
        heartbeatIntervalRef.current = setInterval(() => {
          const now = Date.now();
          connectionsRef.current.forEach((connData, peerId) => {
            if (connData.conn?.open) {
              connData.conn.send({ type: 'heartbeat', timestamp: now });
            }
          });
          
          // Check for stale connections (no heartbeat in 10 seconds)
          // Only check if we have active connections to check
          const activeConnections = Array.from(connectionsRef.current.keys()).filter(id => id !== peerRef.current?.id);
          
          if (activeConnections.length > 0) {
            let hasStaleConnection = false;
            activeConnections.forEach(peerId => {
              const lastHeartbeat = lastHeartbeatRef.current.get(peerId);
              if (!lastHeartbeat || now - lastHeartbeat > 10000) {
                hasStaleConnection = true;
                console.log('Stale connection detected:', peerId);
              }
            });
            
            if (hasStaleConnection && connectionHealth === 'good') {
              setConnectionHealth('degraded');
            } else if (!hasStaleConnection && connectionHealth === 'degraded') {
              setConnectionHealth('good');
            }
          } else if (connectionHealth === 'degraded') {
            // No connections to check, reset to good
            setConnectionHealth('good');
          }
        }, 3000);
        
        return () => {
          if (heartbeatIntervalRef.current) {
            clearInterval(heartbeatIntervalRef.current);
          }
        };
      }, [sessionState, connectionHealth]);

      const syncTeams = (newTeams) => {
        if (isHostRef.current) {
          connectionsRef.current.forEach((connData) => {
            if (connData.conn?.open) connData.conn.send({ type: 'teams-update', teams: newTeams });
          });
        }
      };

      const broadcastBoard = (content) => {
        setBoardContent(content);
        if (isHostRef.current) {
          connectionsRef.current.forEach((connData) => {
            if (connData.conn?.open) connData.conn.send({ type: 'board-update', content });
          });
        }
      };

      const createTeam = () => {
        if (newTeamName.trim()) {
          const newTeam = { id: Date.now(), name: newTeamName.trim(), volume: 80, color: newTeamColor };
          const newTeams = [...teams, newTeam];
          setTeams(newTeams);
          setChannelStates(prev => ({ ...prev, [newTeam.id]: { listen: true, speak: false } }));
          setNewTeamName('');
          setNewTeamColor('#00ff66');
          setShowCreateModal(false);
          syncTeams(newTeams);
        }
      };

      const deleteTeam = (id) => {
        setConnectedUsers(prev => prev.map(u => u.channelId === id ? { ...u, channelId: null } : u));
        const newTeams = teams.filter(t => t.id !== id);
        setTeams(newTeams);
        setChannelStates(prev => { const n = { ...prev }; delete n[id]; return n; });
        syncTeams(newTeams);
      };

      const copyCode = () => navigator.clipboard.writeText(sessionCode);

      useEffect(() => {
        const speakingChannels = getSpeakingChannels();
        setConnectedUsers(prev => prev.map(u => 
          u.peerId === peerRef.current?.id 
            ? { ...u, status: myStatus, speaking: isSpeaking, speakingChannels: speakingChannels } 
            : u
        ));
      }, [myStatus, isSpeaking, allCallActive, getSpeakingChannels]);

      // Drag and drop
      const handleDragStart = (e, user) => { if (isHostRef.current) setDraggedUser(user); };
      const handleDragOver = (e) => { if (isHostRef.current && draggedUser) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; } };
      const handleDragEnter = (e) => { if (isHostRef.current && draggedUser) e.currentTarget.classList.add('drag-over'); };
      const handleDragLeave = (e) => { e.currentTarget.classList.remove('drag-over'); };
      const handleDrop = (e, channelId) => {
        e.preventDefault();
        e.currentTarget.classList.remove('drag-over');
        if (isHostRef.current && draggedUser && !draggedUser.isHost) {
          moveUserToChannel(draggedUser.peerId, channelId);
        }
        setDraggedUser(null);
      };

      const getUsersInChannel = (channelId) => connectedUsers.filter(u => u.channelId === channelId && !u.isHost);
      const getUnassignedUsers = () => connectedUsers.filter(u => u.channelId === null && !u.isHost);
      const getCommandNetUsers = () => connectedUsers.filter(u => u.role === 'commander' || u.role === 'squadleader');

      // Channel card component
      const ChannelCard = ({ channel, isCommandNet = false }) => {
        const channelId = isCommandNet ? COMMAND_NET_ID : channel.id;
        const channelState = channelStates[channelId] || { listen: false, speak: false };
        const channelUsers = isCommandNet ? getCommandNetUsers() : getUsersInChannel(channel.id);
        const channelColor = isCommandNet ? '#ff6b6b' : channel.color;
        const channelName = isCommandNet ? 'COMMAND NET' : channel.name;
        
        const handleChannelTap = () => {
          if (isMobile && selectedUserForAssign && !isCommandNet && myRole === 'commander') {
            moveUserToChannel(selectedUserForAssign.peerId, channel.id);
            setSelectedUserForAssign(null);
          }
        };
        
        return (
          <div
            className={!isCommandNet && !isMobile ? "channel-drop-zone" : ""}
            onDragOver={!isCommandNet && !isMobile ? handleDragOver : undefined}
            onDragEnter={!isCommandNet && !isMobile ? handleDragEnter : undefined}
            onDragLeave={!isCommandNet && !isMobile ? handleDragLeave : undefined}
            onDrop={!isCommandNet && !isMobile ? (e) => handleDrop(e, channel.id) : undefined}
            onClick={handleChannelTap}
            style={{ 
              background: isCommandNet 
                ? 'linear-gradient(135deg, rgba(40,15,15,0.9), rgba(50,20,20,0.9))' 
                : 'linear-gradient(135deg, rgba(10,30,10,0.9), rgba(20,40,20,0.9))', 
              border: `2px solid ${selectedUserForAssign && !isCommandNet ? '#00ff66' : channelState.speak ? channelColor : channelState.listen ? `${channelColor}66` : 'rgba(255,255,255,0.15)'}`,
              borderRadius: '12px', 
              padding: isMobile ? '14px' : '18px',
              boxShadow: channelState.speak ? `0 0 30px ${channelColor}33` : 'none',
              marginBottom: '15px'
            }}
          >
            {isMobile && selectedUserForAssign && !isCommandNet && myRole === 'commander' && (
              <div style={{ background: 'rgba(0,255,100,0.2)', border: '1px solid rgba(0,255,100,0.4)', borderRadius: '6px', padding: '10px', marginBottom: '12px', textAlign: 'center', fontSize: '11px', color: '#00ff66' }}>
                TAP TO MOVE {selectedUserForAssign.username.toUpperCase()} HERE
              </div>
            )}
            
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px', flexWrap: isMobile ? 'wrap' : 'nowrap', gap: '10px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                <div style={{ width: '16px', height: '16px', borderRadius: '50%', background: channelColor, boxShadow: `0 0 10px ${channelColor}66` }} />
                <div>
                  <h2 style={{ margin: 0, fontSize: isMobile ? '14px' : '15px', fontWeight: '500', letterSpacing: '2px', color: channelColor }}>
                    {isCommandNet ? 'ðŸ“¡ ' : ''}{channelName.toUpperCase()}
                  </h2>
                  <span style={{ fontSize: '9px', color: '#5a7a5a' }}>
                    {isCommandNet ? 'LEADERSHIP ONLY' : `${channelUsers.length} OPERATORS`}
                  </span>
                </div>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '8px', width: isMobile ? '100%' : 'auto', justifyContent: isMobile ? 'stretch' : 'flex-end' }}>
                <button
                  onPointerDown={(e) => { e.preventDefault(); e.stopPropagation(); toggleChannelListen(channelId); }}
                  style={{ flex: isMobile ? 1 : 'none', padding: isMobile ? '14px 12px' : '8px 12px', background: channelState.listen ? `${channelColor}33` : 'rgba(0,0,0,0.3)', border: `1px solid ${channelState.listen ? channelColor : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: channelState.listen ? channelColor : '#666', fontSize: isMobile ? '13px' : '11px', cursor: 'pointer', fontFamily: 'inherit', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}
                >
                  ðŸŽ§ {channelState.listen ? 'ON' : 'OFF'}
                </button>
                <button
                  onPointerDown={(e) => { e.preventDefault(); e.stopPropagation(); toggleChannelSpeak(channelId); }}
                  style={{ flex: isMobile ? 1 : 'none', padding: isMobile ? '14px 12px' : '8px 12px', background: channelState.speak ? `${channelColor}33` : 'rgba(0,0,0,0.3)', border: `1px solid ${channelState.speak ? channelColor : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: channelState.speak ? channelColor : '#666', fontSize: isMobile ? '13px' : '11px', cursor: 'pointer', fontFamily: 'inherit', animation: channelState.speak ? 'pulseGlow 1s infinite' : 'none', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}
                >
                  ðŸŽ™ï¸ {channelState.speak ? 'TX' : 'OFF'}
                </button>
                {!isCommandNet && isHostRef.current && !isMobile && (
                  <button onClick={(e) => { e.stopPropagation(); deleteTeam(channel.id); }} style={{ background: 'transparent', border: 'none', color: '#5a3a3a', fontSize: '18px', cursor: 'pointer', padding: '2px 8px' }}>Ã—</button>
                )}
              </div>
            </div>

            <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '15px', padding: isMobile ? '14px 12px' : '10px 12px', background: 'rgba(0,0,0,0.3)', borderRadius: '6px' }}>
              <span style={{ fontSize: '9px', color: '#6a8a6a' }}>VOL</span>
              <input 
                type="range" 
                min="0" 
                max="100" 
                value={isCommandNet ? commandNetVolume : channel.volume} 
                onClick={(e) => e.stopPropagation()}
                onChange={(e) => {
                  if (isCommandNet) {
                    setCommandNetVolume(parseInt(e.target.value));
                  } else {
                    setTeams(prev => prev.map(t => t.id === channel.id ? { ...t, volume: parseInt(e.target.value) } : t));
                  }
                }} 
                style={{ flex: 1, height: '24px', appearance: 'none', WebkitAppearance: 'none', background: `linear-gradient(to right, ${channelColor} ${isCommandNet ? commandNetVolume : channel.volume}%, rgba(100,100,100,0.3) ${isCommandNet ? commandNetVolume : channel.volume}%)`, borderRadius: '4px', cursor: 'pointer' }} 
              />
              <span style={{ fontSize: '11px', color: channelColor, minWidth: '35px', textAlign: 'right' }}>{isCommandNet ? commandNetVolume : channel.volume}%</span>
            </div>

            <div style={{ minHeight: '40px', padding: '10px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px', border: '1px dashed rgba(255,255,255,0.1)' }}>
              {channelUsers.length === 0 ? (
                <div style={{ textAlign: 'center', color: '#4a6a4a', fontSize: '11px', padding: '5px' }}>
                  {isCommandNet ? 'No leadership online' : (isHostRef.current ? (isMobile ? 'Tap to assign users' : 'Drag operators here') : 'No operators')}
                </div>
              ) : (
                <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>
                  {channelUsers.map(user => {
                    const status = statusConfig[user.status || 'standby'];
                    const role = roleConfig[user.role || 'operator'];
                    const isSpeakingHere = user.speaking && user.speakingChannels?.includes(channelId);
                    const isMe = user.peerId === peerRef.current?.id;
                    const canManage = isHostRef.current && !user.isHost && !isCommandNet;
                    
                    return (
                      <div
                        key={user.peerId}
                        draggable={canManage && !isMobile}
                        onDragStart={(e) => !isMobile && handleDragStart(e, user)}
                        onDragEnd={() => setDraggedUser(null)}
                        className={canManage && !isMobile ? 'user-chip' : ''}
                        style={{ 
                          display: 'flex', 
                          flexDirection: 'column',
                          gap: '8px',
                          padding: isMobile ? '14px 16px' : '12px 14px', 
                          background: isSpeakingHere ? 'rgba(0,255,100,0.2)' : (selectedUserForAssign?.peerId === user.peerId ? 'rgba(0,255,100,0.15)' : 'rgba(0,0,0,0.4)'), 
                          border: `2px solid ${isSpeakingHere ? 'rgba(0,255,100,0.5)' : (selectedUserForAssign?.peerId === user.peerId ? '#00ff66' : 'rgba(255,255,255,0.15)')}`, 
                          borderRadius: '8px',
                          minWidth: isMobile ? '140px' : '160px'
                        }}
                      >
                        {/* User info row */}
                        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                          <div style={{ width: isMobile ? '12px' : '10px', height: isMobile ? '12px' : '10px', borderRadius: '50%', background: status.color, boxShadow: `0 0 8px ${status.color}`, animation: isSpeakingHere ? 'pulse 0.5s infinite' : 'none', flexShrink: 0 }} />
                          <div style={{ flex: 1 }}>
                            <div style={{ fontSize: isMobile ? '14px' : '13px', fontWeight: '500', color: isMe ? '#00ff66' : '#e0ffe0', display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' }}>
                              <span style={{ color: role.color }}>{role.icon}</span>
                              {user.username.toUpperCase()}
                              {isMe && <span style={{ fontSize: '9px', color: '#5a8a5a', fontWeight: '400' }}>(YOU)</span>}
                            </div>
                          </div>
                          {isSpeakingHere && (
                            <div style={{ display: 'flex', gap: '2px', alignItems: 'flex-end', height: '14px' }}>
                              {[1,2,3].map(i => (<div key={i} style={{ width: '3px', background: '#00ff66', borderRadius: '1px', animation: 'soundWave 0.5s infinite', animationDelay: `${i*0.1}s` }} />))}
                            </div>
                          )}
                        </div>
                        
                        {/* Action buttons for commander - now on both desktop and mobile */}
                        {canManage && (
                          <div style={{ display: 'flex', gap: '6px' }}>
                            {isMobile && (
                              <button
                                onPointerDown={(e) => {
                                  e.preventDefault();
                                  e.stopPropagation();
                                  setSelectedUserForAssign(selectedUserForAssign?.peerId === user.peerId ? null : user);
                                }}
                                style={{
                                  padding: '10px 8px',
                                  background: selectedUserForAssign?.peerId === user.peerId ? 'rgba(0,255,100,0.2)' : 'rgba(0,255,100,0.1)',
                                  border: `1px solid ${selectedUserForAssign?.peerId === user.peerId ? '#00ff66' : 'rgba(0,255,100,0.4)'}`,
                                  borderRadius: '4px',
                                  color: '#00ff66',
                                  fontSize: '11px',
                                  fontFamily: 'inherit',
                                  cursor: 'pointer',
                                  touchAction: 'manipulation',
                                  userSelect: 'none',
                                  WebkitUserSelect: 'none'
                                }}
                              >
                                {selectedUserForAssign?.peerId === user.peerId ? 'âœ“' : 'â†”'}
                              </button>
                            )}
                            <button
                              onPointerDown={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                user.role === 'squadleader' ? demoteToOperator(user.peerId) : promoteToSquadLeader(user.peerId);
                              }}
                              style={{
                                flex: 1,
                                padding: isMobile ? '10px 8px' : '8px 10px',
                                background: user.role === 'squadleader' ? 'rgba(78,205,196,0.2)' : 'rgba(78,205,196,0.1)',
                                border: `1px solid ${user.role === 'squadleader' ? '#4ecdc4' : 'rgba(78,205,196,0.4)'}`,
                                borderRadius: '4px',
                                color: '#4ecdc4',
                                fontSize: isMobile ? '11px' : '10px',
                                fontFamily: 'inherit',
                                cursor: 'pointer',
                                touchAction: 'manipulation',
                                userSelect: 'none',
                                WebkitUserSelect: 'none'
                              }}
                            >
                              {user.role === 'squadleader' ? 'â†“ DEMOTE' : 'â†‘ PROMOTE'}
                            </button>
                            <button
                              onPointerDown={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                kickUser(user.peerId, user.username);
                              }}
                              style={{
                                padding: isMobile ? '10px 12px' : '8px 10px',
                                background: 'rgba(255,50,50,0.1)',
                                border: '1px solid rgba(255,50,50,0.4)',
                                borderRadius: '4px',
                                color: '#ff6666',
                                fontSize: isMobile ? '11px' : '10px',
                                fontFamily: 'inherit',
                                cursor: 'pointer',
                                touchAction: 'manipulation',
                                userSelect: 'none',
                                WebkitUserSelect: 'none'
                              }}
                            >
                              KICK
                            </button>
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
            
          </div>
        );
      };

      return (
        <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #0a0f0a 0%, #1a1f1a 50%, #0f1a0f 100%)', fontFamily: '"JetBrains Mono", monospace', color: '#e0ffe0', padding: isMobile ? '20px 12px' : '40px 20px', position: 'relative', overflow: 'hidden' }}>
          <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 4px)', pointerEvents: 'none', zIndex: 1000 }} />
          <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, backgroundImage: 'linear-gradient(rgba(0,255,100,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,100,0.03) 1px, transparent 1px)', backgroundSize: '50px 50px', pointerEvents: 'none' }} />

          {incomingWhistle && (
            <div style={{ position: 'fixed', top: '20px', left: '50%', transform: 'translateX(-50%)', background: 'rgba(255,200,0,0.2)', border: '2px solid rgba(255,200,0,0.6)', borderRadius: '10px', padding: '15px 30px', zIndex: 2000, animation: 'flashAlert 0.3s ease-in-out infinite' }}>
              <span style={{ fontSize: '13px', letterSpacing: '2px', color: '#ffcc00' }}>âš ï¸ {incomingWhistle.from.toUpperCase()} â€” {incomingWhistle.type.toUpperCase()} SIGNAL</span>
            </div>
          )}

          <div style={{ maxWidth: '1000px', margin: '0 auto', position: 'relative', zIndex: 1 }}>
            {/* Header */}
            <div style={{ textAlign: 'center', marginBottom: isMobile ? '20px' : '35px' }}>
              <div style={{ display: 'inline-flex', alignItems: 'center', gap: isMobile ? '10px' : '15px', marginBottom: '8px' }}>
                <div style={{ width: isMobile ? '10px' : '12px', height: isMobile ? '10px' : '12px', borderRadius: '50%', background: sessionState !== 'lobby' ? '#00ff66' : '#ff6600', boxShadow: sessionState !== 'lobby' ? '0 0 20px #00ff66' : '0 0 10px #ff6600', animation: sessionState !== 'lobby' ? 'pulse 2s infinite' : 'none' }} />
                <h1 style={{ fontSize: isMobile ? '28px' : '38px', fontWeight: '300', letterSpacing: isMobile ? '4px' : '6px', margin: 0, textShadow: '0 0 30px rgba(0,255,100,0.3)' }}>G-COMMS</h1>
                <div style={{ width: isMobile ? '10px' : '12px', height: isMobile ? '10px' : '12px', borderRadius: '50%', background: sessionState !== 'lobby' ? '#00ff66' : '#ff6600', boxShadow: sessionState !== 'lobby' ? '0 0 20px #00ff66' : '0 0 10px #ff6600', animation: sessionState !== 'lobby' ? 'pulse 2s infinite' : 'none' }} />
              </div>
              <p style={{ fontSize: isMobile ? '9px' : '10px', letterSpacing: isMobile ? '2px' : '3px', color: '#6a9a6a', margin: 0 }}>GBRS COMMUNICATIONS SYSTEM v.0.9.4</p>
              {sessionState !== 'lobby' && (
                <div style={{ marginTop: '8px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }}>
                  <div style={{ 
                    width: '8px', 
                    height: '8px', 
                    borderRadius: '50%', 
                    background: connectionHealth === 'good' ? '#00ff66' : connectionHealth === 'degraded' ? '#ffaa00' : '#ff6666',
                    boxShadow: `0 0 8px ${connectionHealth === 'good' ? '#00ff66' : connectionHealth === 'degraded' ? '#ffaa00' : '#ff6666'}`,
                    animation: connectionHealth === 'reconnecting' ? 'pulse 0.5s infinite' : 'none'
                  }} />
                  <span style={{ fontSize: '9px', color: connectionHealth === 'good' ? '#4a8a4a' : connectionHealth === 'degraded' ? '#aa8833' : '#aa4444', letterSpacing: '1px' }}>
                    {connectionHealth === 'good' ? 'CONNECTED' : connectionHealth === 'degraded' ? 'UNSTABLE' : `RECONNECTING${reconnectAttempts > 0 ? ` (${reconnectAttempts}/5)` : ''}...`}
                  </span>
                </div>
              )}
            </div>

            {/* Lobby */}
            {sessionState === 'lobby' && (
              <div style={{ maxWidth: '450px', margin: '0 auto', padding: isMobile ? '0' : '0' }}>
                <div style={{ marginBottom: '30px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', marginBottom: '10px' }}>YOUR CALLSIGN</label>
                  <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} placeholder="Enter callsign..." style={{ width: '100%', padding: isMobile ? '18px 20px' : '15px 20px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '16px', outline: 'none', fontFamily: 'inherit' }} />
                </div>
                {error && <div style={{ padding: '12px', background: 'rgba(255,50,50,0.1)', border: '1px solid rgba(255,50,50,0.3)', borderRadius: '6px', color: '#ff6666', fontSize: '12px', marginBottom: '20px', textAlign: 'center' }}>{error}</div>}
                <button onClick={hostSession} style={{ width: '100%', padding: isMobile ? '22px' : '20px', marginBottom: '15px', background: 'linear-gradient(135deg, rgba(0,255,100,0.15), rgba(0,200,80,0.1))', border: '2px solid rgba(0,255,100,0.4)', borderRadius: '12px', color: '#00ff66', fontSize: isMobile ? '15px' : '14px', fontWeight: '600', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>ðŸ›°ï¸ HOST NEW SESSION</button>
                <div style={{ textAlign: 'center', padding: '15px 0', color: '#4a6a4a', fontSize: '11px', letterSpacing: '2px' }}>â€” OR â€”</div>
                <div style={{ background: 'rgba(0,20,0,0.4)', border: '1px solid rgba(0,255,100,0.15)', borderRadius: '12px', padding: isMobile ? '24px 20px' : '20px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '3px', color: '#6a9a6a', marginBottom: '10px' }}>SESSION CODE</label>
                  <input type="text" value={joinCode} onChange={(e) => setJoinCode(e.target.value.toUpperCase())} placeholder="XXXXXX" maxLength={6} style={{ width: '100%', padding: isMobile ? '18px' : '15px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '24px', letterSpacing: '8px', outline: 'none', fontFamily: 'inherit', textAlign: 'center', marginBottom: '15px' }} />
                  <button onClick={joinSession} style={{ width: '100%', padding: isMobile ? '18px' : '15px', background: 'transparent', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#8ac88a', fontSize: '12px', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>JOIN SESSION</button>
                </div>
              </div>
            )}

            {/* Session */}
            {(sessionState === 'hosting' || sessionState === 'joined') && (
              <>
                {/* Top Bar */}
                <div style={{ display: 'flex', flexDirection: isMobile ? 'column' : 'row', justifyContent: 'space-between', alignItems: isMobile ? 'stretch' : 'center', padding: isMobile ? '12px' : '12px 18px', background: 'rgba(0,20,0,0.6)', border: '1px solid rgba(0,255,100,0.2)', borderRadius: '10px', marginBottom: '15px', gap: '12px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: isMobile ? '12px' : '20px', flexWrap: 'wrap', justifyContent: isMobile ? 'center' : 'flex-start' }}>
                    <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>SESSION</span>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '4px', justifyContent: isMobile ? 'center' : 'flex-start' }}>
                        <span style={{ fontSize: isMobile ? '16px' : '18px', letterSpacing: '4px', color: '#00ff66', fontWeight: '600' }}>{sessionCode}</span>
                        <button onClick={copyCode} style={{ background: 'rgba(0,255,100,0.1)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '4px', color: '#00ff66', padding: '6px 10px', fontSize: '9px', cursor: 'pointer', fontFamily: 'inherit' }}>COPY</button>
                        {wakeLockActive && <span title="Screen will stay on" style={{ fontSize: '12px' }}>â˜€ï¸</span>}
                      </div>
                    </div>
                    {!isMobile && <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />}
                    <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>ROLE</span>
                      <div style={{ fontSize: '12px', marginTop: '4px', color: roleConfig[myRole].color, display: 'flex', alignItems: 'center', gap: '6px', justifyContent: isMobile ? 'center' : 'flex-start' }}>
                        {roleConfig[myRole].icon} {roleConfig[myRole].label}
                      </div>
                    </div>
                    {myRole === 'operator' && myChannelId && (
                      <>
                        {!isMobile && <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />}
                        <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                          <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>CHANNEL</span>
                          <div style={{ fontSize: '12px', marginTop: '4px', color: teams.find(t => t.id === myChannelId)?.color || '#00ff66' }}>
                            {teams.find(t => t.id === myChannelId)?.name.toUpperCase() || 'UNASSIGNED'}
                          </div>
                        </div>
                      </>
                    )}
                    {!isMobile && <div style={{ width: '1px', height: '35px', background: 'rgba(0,255,100,0.2)' }} />}
                    <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                      <span style={{ fontSize: '9px', color: '#5a8a5a', letterSpacing: '2px' }}>STATUS</span>
                      <div style={{ fontSize: '12px', marginTop: '4px', color: statusConfig[myStatus].color }}>{statusConfig[myStatus].icon} {statusConfig[myStatus].label}</div>
                    </div>
                  </div>
                  <div style={{ display: 'flex', gap: '8px', justifyContent: isMobile ? 'center' : 'flex-end' }}>
                    <button onPointerDown={(e) => { e.preventDefault(); setGlobalMute(!globalMute); }} style={{ background: globalMute ? 'rgba(255,50,50,0.2)' : 'rgba(0,255,100,0.1)', border: `1px solid ${globalMute ? 'rgba(255,50,50,0.5)' : 'rgba(0,255,100,0.3)'}`, borderRadius: '6px', color: globalMute ? '#ff6666' : '#00ff66', padding: isMobile ? '12px 16px' : '8px 12px', fontSize: '16px', cursor: 'pointer', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}>{globalMute ? 'ðŸ”‡' : 'ðŸ”Š'}</button>
                    <button onClick={leaveSession} style={{ background: 'rgba(255,50,50,0.1)', border: '1px solid rgba(255,50,50,0.3)', borderRadius: '6px', color: '#ff6666', padding: isMobile ? '12px 18px' : '8px 14px', fontSize: '10px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>LEAVE</button>
                  </div>
                </div>

                {/* Signals */}
                <div style={{ display: 'flex', gap: '8px', marginBottom: '15px', padding: isMobile ? '12px' : '15px', background: 'rgba(0,20,0,0.4)', border: '1px solid rgba(255,200,0,0.2)', borderRadius: '10px', flexWrap: 'wrap' }}>
                  <span style={{ fontSize: '10px', letterSpacing: '2px', color: '#aa9944', display: 'flex', alignItems: 'center', marginRight: '5px', width: isMobile ? '100%' : 'auto', justifyContent: isMobile ? 'center' : 'flex-start', marginBottom: isMobile ? '8px' : '0' }}>SIGNALS</span>
                  <button onPointerDown={(e) => { e.preventDefault(); broadcastWhistle('attention'); }} style={{ flex: 1, minWidth: isMobile ? '30%' : '100px', padding: isMobile ? '14px 10px' : '10px 15px', background: 'rgba(255,200,0,0.1)', border: '1px solid rgba(255,200,0,0.4)', borderRadius: '6px', color: '#ffcc00', fontSize: isMobile ? '10px' : '11px', cursor: 'pointer', fontFamily: 'inherit', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}>ðŸ“¯ ATTN</button>
                  <button onPointerDown={(e) => { e.preventDefault(); broadcastWhistle('alert'); }} style={{ flex: 1, minWidth: isMobile ? '30%' : '100px', padding: isMobile ? '14px 10px' : '10px 15px', background: 'rgba(255,150,0,0.1)', border: '1px solid rgba(255,150,0,0.4)', borderRadius: '6px', color: '#ff9900', fontSize: isMobile ? '10px' : '11px', cursor: 'pointer', fontFamily: 'inherit', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}>ðŸ”” ALERT</button>
                  <button onPointerDown={(e) => { e.preventDefault(); broadcastWhistle('urgent'); }} style={{ flex: 1, minWidth: isMobile ? '30%' : '100px', padding: isMobile ? '14px 10px' : '10px 15px', background: 'rgba(255,80,80,0.1)', border: '1px solid rgba(255,80,80,0.4)', borderRadius: '6px', color: '#ff6666', fontSize: isMobile ? '10px' : '11px', cursor: 'pointer', fontFamily: 'inherit', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}>âš ï¸ URGENT</button>
                </div>

                {/* ALL-CALL Panel (Commander only) */}
                {myRole === 'commander' && (
                  <div style={{ background: allCallActive ? 'rgba(255,50,50,0.2)' : 'rgba(0,20,0,0.5)', border: `2px solid ${allCallActive ? 'rgba(255,100,100,0.6)' : 'rgba(0,255,100,0.2)'}`, borderRadius: '10px', padding: isMobile ? '12px' : '15px', marginBottom: '15px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexDirection: isMobile ? 'column' : 'row', gap: '12px' }}>
                      <div style={{ textAlign: isMobile ? 'center' : 'left' }}>
                        <span style={{ fontSize: '11px', letterSpacing: '2px', color: '#ffcc00' }}>â˜… COMMANDER BROADCAST</span>
                        {!isMobile && <div style={{ fontSize: '9px', color: '#5a7a5a', marginTop: '4px' }}>Ctrl+0: All-Call to ALL squads simultaneously</div>}
                      </div>
                      <button 
                        onPointerDown={(e) => { e.preventDefault(); setAllCallActive(!allCallActive); }}
                        style={{ 
                          padding: isMobile ? '16px 32px' : '12px 24px', 
                          background: allCallActive ? 'rgba(255,50,50,0.3)' : 'rgba(255,50,50,0.1)', 
                          border: `2px solid ${allCallActive ? '#ff6666' : 'rgba(255,100,100,0.4)'}`,
                          borderRadius: '8px', 
                          color: allCallActive ? '#ff6666' : '#ff9999', 
                          fontSize: isMobile ? '14px' : '12px', 
                          fontWeight: '600',
                          letterSpacing: '2px', 
                          cursor: 'pointer', 
                          fontFamily: 'inherit',
                          animation: allCallActive ? 'pulse 0.5s infinite' : 'none',
                          width: isMobile ? '100%' : 'auto',
                          touchAction: 'manipulation',
                          userSelect: 'none',
                          WebkitUserSelect: 'none'
                        }}
                      >
                        ðŸ“¢ ALL-CALL {allCallActive ? 'ACTIVE' : 'OFF'}
                      </button>
                    </div>
                  </div>
                )}

                {/* Mobile: Commander's Board inline */}
                {(boardContent || myRole === 'commander') && isMobile && (
                  <div style={{
                    background: 'rgba(0,20,40,0.4)',
                    border: '1px solid rgba(100,150,255,0.3)',
                    borderRadius: '10px',
                    marginBottom: '15px',
                    overflow: 'hidden'
                  }}>
                    <div
                      onClick={() => setBoardExpanded(!boardExpanded)}
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        padding: '12px 15px',
                        background: 'rgba(0,0,0,0.2)',
                        cursor: 'pointer',
                        userSelect: 'none'
                      }}
                    >
                      <span style={{ fontSize: '10px', letterSpacing: '2px', color: '#88aaff' }}>
                        ðŸ“‹ COMMANDER'S BOARD
                      </span>
                      <span style={{ fontSize: '12px', color: '#88aaff' }}>
                        {boardExpanded ? 'â–¼' : 'â–¶'}
                      </span>
                    </div>
                    {boardExpanded && (
                      <div style={{ padding: '12px' }}>
                        {myRole === 'commander' ? (
                          <>
                            <div style={{ display: 'flex', gap: '6px', marginBottom: '10px', flexWrap: 'wrap' }}>
                              <button onClick={() => document.execCommand('bold')} style={{ padding: '8px 12px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', color: '#ccc', fontSize: '12px', fontWeight: 'bold', cursor: 'pointer', fontFamily: 'inherit' }}>B</button>
                              <button onClick={() => document.execCommand('italic')} style={{ padding: '8px 12px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', color: '#ccc', fontSize: '12px', fontStyle: 'italic', cursor: 'pointer', fontFamily: 'inherit' }}>I</button>
                              <button onClick={() => document.execCommand('underline')} style={{ padding: '8px 12px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', color: '#ccc', fontSize: '12px', textDecoration: 'underline', cursor: 'pointer', fontFamily: 'inherit' }}>U</button>
                              <button onClick={() => document.execCommand('formatBlock', false, 'h2')} style={{ padding: '8px 12px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', color: '#ccc', fontSize: '11px', cursor: 'pointer', fontFamily: 'inherit' }}>H1</button>
                              <button onClick={() => document.execCommand('formatBlock', false, 'h3')} style={{ padding: '8px 12px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', color: '#ccc', fontSize: '10px', cursor: 'pointer', fontFamily: 'inherit' }}>H2</button>
                            </div>
                            <div
                              contentEditable
                              onBlur={(e) => broadcastBoard(e.target.innerHTML)}
                              suppressContentEditableWarning={true}
                              style={{
                                minHeight: '100px',
                                padding: '12px',
                                background: 'rgba(0,0,0,0.3)',
                                border: '1px solid rgba(100,150,255,0.2)',
                                borderRadius: '6px',
                                color: '#e0ffe0',
                                fontSize: '13px',
                                lineHeight: '1.5',
                                outline: 'none',
                                fontFamily: 'inherit'
                              }}
                            />
                          </>
                        ) : (
                          <div
                            dangerouslySetInnerHTML={{ __html: boardContent || '<span style="color:#5a7a8a">No orders posted</span>' }}
                            style={{
                              padding: '12px',
                              background: 'rgba(0,0,0,0.2)',
                              borderRadius: '6px',
                              color: '#e0ffe0',
                              fontSize: '13px',
                              lineHeight: '1.5'
                            }}
                          />
                        )}
                      </div>
                    )}
                  </div>
                )}

                {/* TX Status - Always visible */}
                <div style={{ marginBottom: '15px', padding: '12px 18px', background: isSpeaking ? (allCallActive ? 'rgba(255,50,50,0.2)' : 'rgba(0,100,0,0.3)') : 'rgba(0,20,0,0.4)', border: `1px solid ${isSpeaking ? (allCallActive ? 'rgba(255,100,100,0.4)' : 'rgba(0,255,100,0.4)') : 'rgba(100,100,100,0.2)'}`, borderRadius: '8px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                    <span style={{ fontSize: '10px', letterSpacing: '2px', color: isSpeaking ? (noiseGateOpen ? (allCallActive ? '#ff6666' : '#00ff66') : '#888800') : '#666' }}>
                      {isSpeaking
                        ? `ðŸŽ™ï¸ ${noiseGateOpen ? 'TX' : 'GATE'} â†’ ${allCallActive ? 'ðŸ“¢ ALL SQUADS' : getSpeakingChannels().map(ch => ch === COMMAND_NET_ID ? 'CMD NET' : teams.find(t => t.id === ch)?.name || ch).join(', ') || 'NONE'}`
                        : 'ðŸŽ™ï¸ TX OFF â€” Click speak button on a channel'
                      }
                    </span>
                    {isSpeaking && (
                      <>
                        <div style={{ flex: 1, height: '8px', background: 'rgba(0,0,0,0.5)', borderRadius: '4px', overflow: 'hidden', position: 'relative' }}>
                          {/* Threshold marker */}
                          <div style={{ position: 'absolute', left: `${noiseGateThreshold}%`, top: 0, bottom: 0, width: '2px', background: '#ffaa00', zIndex: 2 }} />
                          {/* Audio level bar */}
                          <div style={{ width: `${audioLevel * 100}%`, height: '100%', background: noiseGateOpen ? (audioLevel > 0.7 ? 'linear-gradient(90deg, #00ff66, #ffff00, #ff3300)' : (allCallActive ? '#ff6666' : '#00ff66')) : '#666600', transition: 'width 0.05s' }} />
                        </div>
                        <span style={{ fontSize: '11px', fontWeight: 'bold', color: noiseGateOpen ? (audioLevel > 0.7 ? '#ff3300' : (allCallActive ? '#ff6666' : '#00ff66')) : '#888800', minWidth: '35px' }}>{Math.round(audioLevel * 100)}%</span>
                      </>
                    )}
                  </div>
                  {/* Noise Gate Sensitivity */}
                  <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '10px', paddingTop: '10px', borderTop: '1px solid rgba(255,255,255,0.1)' }}>
                    <span style={{ fontSize: '9px', color: '#888', letterSpacing: '1px', whiteSpace: 'nowrap' }}>ðŸšª GATE</span>
                    <input
                      type="range"
                      min="0"
                      max="50"
                      value={noiseGateThreshold}
                      onChange={(e) => setNoiseGateThreshold(parseInt(e.target.value))}
                      style={{
                        flex: 1,
                        height: '20px',
                        appearance: 'none',
                        WebkitAppearance: 'none',
                        background: `linear-gradient(to right, #666600 ${noiseGateThreshold * 2}%, rgba(100,100,100,0.3) ${noiseGateThreshold * 2}%)`,
                        borderRadius: '4px',
                        cursor: 'pointer'
                      }}
                    />
                    <span style={{ fontSize: '9px', color: '#ffaa00', minWidth: '30px' }}>{noiseGateThreshold}%</span>
                  </div>
                  <div style={{ fontSize: '8px', color: '#5a6a5a', marginTop: '4px' }}>
                    {noiseGateThreshold === 0 ? 'Gate off â€” all audio passes through' : `Blocks audio below ${noiseGateThreshold}% to reduce background noise`}
                  </div>
                </div>

                {/* Mobile: Floating move indicator */}
                {isMobile && selectedUserForAssign && myRole === 'commander' && (
                  <div style={{ 
                    position: 'sticky', 
                    top: '10px', 
                    zIndex: 100, 
                    background: 'rgba(0,50,0,0.95)', 
                    border: '2px solid #00ff66', 
                    borderRadius: '8px', 
                    padding: '12px 16px', 
                    marginBottom: '15px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: '10px',
                    boxShadow: '0 4px 20px rgba(0,255,100,0.3)'
                  }}>
                    <span style={{ fontSize: '12px', color: '#00ff66' }}>
                      â†” MOVING: <strong>{selectedUserForAssign.username.toUpperCase()}</strong>
                    </span>
                    <button
                      onPointerDown={(e) => { e.preventDefault(); setSelectedUserForAssign(null); }}
                      style={{
                        padding: '8px 12px',
                        background: 'rgba(255,50,50,0.2)',
                        border: '1px solid rgba(255,50,50,0.5)',
                        borderRadius: '4px',
                        color: '#ff6666',
                        fontSize: '11px',
                        fontFamily: 'inherit',
                        cursor: 'pointer',
                        touchAction: 'manipulation'
                      }}
                    >
                      CANCEL
                    </button>
                  </div>
                )}

                {/* Hotkeys (Desktop) / Status Buttons (Mobile) */}
                {isMobile ? (
                  <div style={{ marginBottom: '15px', padding: '12px', background: 'rgba(0,0,0,0.3)', borderRadius: '8px' }}>
                    <div style={{ fontSize: '9px', color: '#5a7a5a', textAlign: 'center', marginBottom: '10px' }}>SET STATUS</div>
                    <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center' }}>
                      <button onPointerDown={(e) => { e.preventDefault(); broadcastStatus('ready'); }} style={{ padding: '12px 16px', background: myStatus === 'ready' ? 'rgba(0,255,100,0.2)' : 'rgba(0,0,0,0.3)', border: `1px solid ${myStatus === 'ready' ? '#00ff66' : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: '#00ff66', fontSize: '11px', fontFamily: 'inherit', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}>ðŸŸ¢ READY</button>
                      <button onPointerDown={(e) => { e.preventDefault(); broadcastStatus('wait'); }} style={{ padding: '12px 16px', background: myStatus === 'wait' ? 'rgba(255,170,0,0.2)' : 'rgba(0,0,0,0.3)', border: `1px solid ${myStatus === 'wait' ? '#ffaa00' : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: '#ffaa00', fontSize: '11px', fontFamily: 'inherit', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}>ðŸŸ¡ WAIT</button>
                      <button onPointerDown={(e) => { e.preventDefault(); broadcastStatus('dead'); }} style={{ padding: '12px 16px', background: myStatus === 'dead' ? 'rgba(255,50,50,0.2)' : 'rgba(0,0,0,0.3)', border: `1px solid ${myStatus === 'dead' ? '#ff4444' : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: '#ff4444', fontSize: '11px', fontFamily: 'inherit', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}>ðŸ”´ DOWN</button>
                      <button onPointerDown={(e) => { e.preventDefault(); broadcastStatus('standby'); }} style={{ padding: '12px 16px', background: myStatus === 'standby' ? 'rgba(100,100,100,0.2)' : 'rgba(0,0,0,0.3)', border: `1px solid ${myStatus === 'standby' ? '#666' : 'rgba(100,100,100,0.3)'}`, borderRadius: '6px', color: '#888', fontSize: '11px', fontFamily: 'inherit', touchAction: 'manipulation', userSelect: 'none', WebkitUserSelect: 'none' }}>âš« STANDBY</button>
                    </div>
                  </div>
                ) : (
                  <div style={{ marginBottom: '15px', padding: '10px 15px', background: 'rgba(0,0,0,0.3)', borderRadius: '6px', display: 'flex', gap: '15px', flexWrap: 'wrap', justifyContent: 'center' }}>
                    <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+M</kbd> Mute</span>
                    <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Shift+A</kbd> Ready</span>
                    <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Alt+D</kbd> Down</span>
                    <span style={{ fontSize: '9px', color: '#5a7a5a' }}><kbd style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 5px', borderRadius: '3px' }}>Ctrl+Alt+W</kbd> Wait</span>
                  </div>
                )}

                {/* Two-column layout: Channels (left) + Board (right) on desktop */}
                <div style={{ display: 'flex', gap: '15px', alignItems: 'flex-start' }}>
                  {/* Left column: Channels */}
                  <div style={{ flex: 1, minWidth: 0 }}>

                {/* Unassigned Users (Commander only) */}
                {myRole === 'commander' && getUnassignedUsers().length > 0 && (
                  <div style={{ background: 'rgba(100,50,0,0.2)', border: '1px solid rgba(255,150,0,0.3)', borderRadius: '10px', padding: isMobile ? '12px' : '15px', marginBottom: '15px' }}>
                    <div style={{ fontSize: '10px', letterSpacing: '2px', color: '#ff9900', marginBottom: '10px' }}>
                      âš ï¸ UNASSIGNED â€” {isMobile ? 'Tap user, then tap channel' : 'Drag to channel'}
                    </div>
                    <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                      {getUnassignedUsers().map(user => (
                        <div
                          key={user.peerId}
                          style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}
                        >
                          <div
                            draggable={!isMobile}
                            onDragStart={(e) => !isMobile && handleDragStart(e, user)}
                            onDragEnd={() => setDraggedUser(null)}
                            onClick={() => isMobile && setSelectedUserForAssign(selectedUserForAssign?.peerId === user.peerId ? null : user)}
                            className={!isMobile ? "user-chip" : ""}
                            style={{ 
                              display: 'flex', 
                              alignItems: 'center', 
                              gap: '8px', 
                              padding: isMobile ? '12px 16px' : '8px 12px', 
                              background: selectedUserForAssign?.peerId === user.peerId ? 'rgba(0,255,100,0.2)' : 'rgba(0,0,0,0.4)', 
                              border: `2px solid ${selectedUserForAssign?.peerId === user.peerId ? '#00ff66' : 'rgba(255,150,0,0.4)'}`, 
                              borderRadius: '6px',
                              cursor: 'pointer'
                            }}
                          >
                            <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: statusConfig[user.status || 'standby'].color }} />
                            <span style={{ fontSize: isMobile ? '12px' : '11px' }}>{user.username.toUpperCase()}</span>
                            {selectedUserForAssign?.peerId === user.peerId && <span style={{ fontSize: '10px', color: '#00ff66' }}>âœ“</span>}
                          </div>
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              kickUser(user.peerId, user.username);
                            }}
                            style={{
                              padding: isMobile ? '8px' : '4px 8px',
                              background: 'rgba(255,50,50,0.1)',
                              border: '1px solid rgba(255,50,50,0.4)',
                              borderRadius: '4px',
                              color: '#ff6666',
                              fontSize: '9px',
                              fontFamily: 'inherit',
                              cursor: 'pointer'
                            }}
                          >
                            KICK
                          </button>
                        </div>
                      ))}
                    </div>
                    {isMobile && selectedUserForAssign && (
                      <div style={{ marginTop: '10px', fontSize: '10px', color: '#00ff66', textAlign: 'center' }}>
                        Now tap a channel below to assign {selectedUserForAssign.username.toUpperCase()}
                      </div>
                    )}
                  </div>
                )}

                {/* Command Net (only visible to commander and squad leaders) */}
                {canSeeCommandNet(myRole) && (
                  <ChannelCard isCommandNet={true} channel={{}} />
                )}

                {/* Create Channel (Commander) */}
                {myRole === 'commander' && (
                  <button onClick={() => setShowCreateModal(true)} style={{ width: '100%', padding: isMobile ? '18px' : '16px', marginBottom: '15px', background: 'transparent', border: '2px dashed rgba(0,255,100,0.3)', borderRadius: '12px', color: '#4a8a4a', fontSize: '12px', letterSpacing: '3px', cursor: 'pointer', fontFamily: 'inherit' }}>+ CREATE CHANNEL</button>
                )}

                {/* Squad Channels */}
                {myRole === 'commander' && teams.map(team => (
                  <ChannelCard key={team.id} channel={team} />
                ))}

                {/* Squad Leader view - their squad + command net */}
                {myRole === 'squadleader' && teams.filter(t => t.id === myChannelId).map(team => (
                  <ChannelCard key={team.id} channel={team} />
                ))}

                {/* Operator view - just their squad */}
                {myRole === 'operator' && teams.filter(t => t.id === myChannelId).map(team => (
                  <ChannelCard key={team.id} channel={team} />
                ))}

                {myRole === 'operator' && !myChannelId && (
                  <div style={{ textAlign: 'center', padding: '50px', color: '#ff9900', background: 'rgba(100,50,0,0.2)', borderRadius: '12px', border: '1px solid rgba(255,150,0,0.3)' }}>
                    <p style={{ fontSize: '14px', letterSpacing: '2px', marginBottom: '10px' }}>â³ AWAITING ASSIGNMENT</p>
                    <p style={{ fontSize: '11px', color: '#aa7733' }}>Commander will assign you to a channel</p>
                  </div>
                )}

                  </div>
                  {/* End left column */}

                  {/* Right column: Commander's Board (desktop only) */}
                  {!isMobile && (boardContent || myRole === 'commander') && (
                    <div style={{
                      width: '250px',
                      flexShrink: 0,
                      background: 'rgba(0,20,40,0.4)',
                      border: '1px solid rgba(100,150,255,0.3)',
                      borderRadius: '10px',
                      overflow: 'hidden',
                      alignSelf: 'stretch'
                    }}>
                      <div style={{
                        padding: '10px 12px',
                        background: 'rgba(0,0,0,0.2)',
                        borderBottom: '1px solid rgba(100,150,255,0.2)',
                        fontSize: '9px',
                        letterSpacing: '2px',
                        color: '#88aaff'
                      }}>
                        ðŸ“‹ COMMANDER'S BOARD
                      </div>
                      <div style={{ padding: '10px', height: 'calc(100% - 40px)', overflow: 'auto' }}>
                        {myRole === 'commander' ? (
                          <>
                            <div style={{ display: 'flex', gap: '3px', marginBottom: '8px', flexWrap: 'wrap' }}>
                              <button onClick={() => document.execCommand('bold')} style={{ padding: '4px 7px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '3px', color: '#ccc', fontSize: '10px', fontWeight: 'bold', cursor: 'pointer', fontFamily: 'inherit' }}>B</button>
                              <button onClick={() => document.execCommand('italic')} style={{ padding: '4px 7px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '3px', color: '#ccc', fontSize: '10px', fontStyle: 'italic', cursor: 'pointer', fontFamily: 'inherit' }}>I</button>
                              <button onClick={() => document.execCommand('underline')} style={{ padding: '4px 7px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '3px', color: '#ccc', fontSize: '10px', textDecoration: 'underline', cursor: 'pointer', fontFamily: 'inherit' }}>U</button>
                              <button onClick={() => document.execCommand('formatBlock', false, 'h3')} style={{ padding: '4px 7px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '3px', color: '#ccc', fontSize: '9px', cursor: 'pointer', fontFamily: 'inherit' }}>H</button>
                            </div>
                            <div
                              ref={boardEditorRef}
                              contentEditable
                              onBlur={(e) => broadcastBoard(e.target.innerHTML)}
                              suppressContentEditableWarning={true}
                              style={{
                                minHeight: '150px',
                                padding: '8px',
                                background: 'rgba(0,0,0,0.3)',
                                border: '1px solid rgba(100,150,255,0.2)',
                                borderRadius: '5px',
                                color: '#e0ffe0',
                                fontSize: '11px',
                                lineHeight: '1.4',
                                outline: 'none',
                                fontFamily: 'inherit'
                              }}
                            />
                            <div style={{ fontSize: '8px', color: '#5a7a8a', marginTop: '5px' }}>
                              Syncs on blur
                            </div>
                          </>
                        ) : (
                          <div
                            dangerouslySetInnerHTML={{ __html: boardContent || '<span style="color:#5a7a8a">No orders posted</span>' }}
                            style={{
                              padding: '8px',
                              background: 'rgba(0,0,0,0.2)',
                              borderRadius: '5px',
                              color: '#e0ffe0',
                              fontSize: '11px',
                              lineHeight: '1.4'
                            }}
                          />
                        )}
                      </div>
                    </div>
                  )}
                </div>
                {/* End two-column layout */}

                {/* Notification when commander is broadcasting ALL-CALL */}
                {connectedUsers.find(u => u.isHost && u.speaking && u.speakingChannels && u.speakingChannels.length > 1) && myRole !== 'commander' && (
                  <div style={{ position: 'fixed', bottom: '20px', left: '50%', transform: 'translateX(-50%)', background: 'rgba(255,50,50,0.2)', border: '2px solid rgba(255,100,100,0.6)', borderRadius: '10px', padding: '12px 24px', zIndex: 2000, animation: 'pulse 0.5s infinite' }}>
                    <span style={{ fontSize: '12px', letterSpacing: '2px', color: '#ff6666' }}>
                      ðŸ“¢ COMMANDER ALL-CALL
                    </span>
                  </div>
                )}
              </>
            )}
          </div>

          {/* Create Modal */}
          {showCreateModal && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }} onClick={() => setShowCreateModal(false)}>
              <div style={{ background: 'linear-gradient(135deg, #0f1f0f, #1a2a1a)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '16px', padding: '35px', width: '380px', maxWidth: '90vw' }} onClick={(e) => e.stopPropagation()}>
                <h3 style={{ margin: '0 0 25px 0', fontSize: '14px', letterSpacing: '4px', textAlign: 'center' }}>NEW CHANNEL</h3>
                <input type="text" value={newTeamName} onChange={(e) => setNewTeamName(e.target.value)} placeholder="Channel name..." autoFocus style={{ width: '100%', padding: '14px 18px', background: 'rgba(0,0,0,0.4)', border: '1px solid rgba(0,255,100,0.3)', borderRadius: '8px', color: '#e0ffe0', fontSize: '14px', outline: 'none', fontFamily: 'inherit', marginBottom: '18px' }} onKeyDown={(e) => e.key === 'Enter' && createTeam()} />
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ display: 'block', fontSize: '10px', letterSpacing: '2px', color: '#6a9a6a', marginBottom: '10px' }}>COLOR</label>
                  <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                    {colorOptions.map(color => (<div key={color} onClick={() => setNewTeamColor(color)} style={{ width: '28px', height: '28px', borderRadius: '6px', background: color, cursor: 'pointer', border: newTeamColor === color ? '3px solid white' : '3px solid transparent', boxShadow: newTeamColor === color ? `0 0 15px ${color}` : 'none' }} />))}
                  </div>
                </div>
                <div style={{ display: 'flex', gap: '10px' }}>
                  <button onClick={() => setShowCreateModal(false)} style={{ flex: 1, padding: '12px', background: 'transparent', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '6px', color: '#888', fontSize: '11px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>CANCEL</button>
                  <button onClick={createTeam} style={{ flex: 1, padding: '12px', background: `${newTeamColor}33`, border: `1px solid ${newTeamColor}88`, borderRadius: '6px', color: newTeamColor, fontSize: '11px', letterSpacing: '2px', cursor: 'pointer', fontFamily: 'inherit' }}>CREATE</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<VoIPApp />);
  </script>
</body>
</html>
